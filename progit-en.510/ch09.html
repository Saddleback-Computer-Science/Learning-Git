<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Pro Git</title>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
    <link rel="stylesheet" type="text/css" href="theme/html/html.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  </head>
  <body data-type="book">
    <div class="navbar">
      <h1>Pro Git</h1>
      <p><a href="toc01.html">Table of Contents</a></p>
    </div>
    <section data-type="chapter" data-pdf-bookmark="Chapter 9. Git and Other Systems" id="idp27314000">
<h1>Git and Other Systems</h1>


<p>The world isn’t perfect.
Usually, you can’t immediately switch every project you come in contact with to Git.
Sometimes you’re stuck on a project using another VCS, and wish it was Git.
We’ll spend the first part of this chapter learning about ways to use Git as a client when the project you’re working on is hosted in a different system.</p>

<p>At some point, you may want to convert your existing project to Git.
The second part of this chapter covers how to migrate your project into Git from several specific systems, as well as a method that will work if no pre-built import tool exists.</p>






<section data-type="sect1" data-pdf-bookmark="Git as a Client" id="idp27426848">
<h1>Git as a Client</h1>

<p><a data-type="indexterm" data-primary="Git as a client" id="idp27428288"/>
Git provides such a nice experience for developers that many people have figured out how to use it on their workstation, even if the rest of their team is using an entirely different VCS.
There are a number of these adapters, called “bridges,” available.
Here we’ll cover the ones you’re most likely to run into in the wild.</p>








<section data-type="sect2" data-pdf-bookmark="Git and Subversion" id="_git_svn">
<h2>Git and Subversion</h2>

<p><a data-type="indexterm" data-primary="Subversion" id="idp27431440"/><a data-type="indexterm" data-primary="Interoperation with other VCSs" data-secondary="Subversion" id="idp27432144"/>
A large fraction of open source development projects and a good number of corporate projects use Subversion to manage their source code.
It’s been around for more than a decade, and for most of that time was the <em>de facto</em> VCS choice for open-source projects.
It’s also very similar in many ways to CVS, which was the big boy of the source-control world before that.</p>

<p><a data-type="indexterm" data-primary="git commands" data-secondary="svn" id="idp27434240"/><a data-type="indexterm" data-primary="git-svn" id="idp27435216"/>
One of Git’s great features is a bidirectional bridge to Subversion called <code>git svn</code>.
This tool allows you to use Git as a valid client to a Subversion server, so you can use all the local features of Git and then push to a Subversion server as if you were using Subversion locally.
This means you can do local branching and merging, use the staging area, use rebasing and cherry-picking, and so on, while your collaborators continue to work in their dark and ancient ways.
It’s a good way to sneak Git into the corporate environment and help your fellow developers become more efficient while you lobby to get the infrastructure changed to support Git fully.
The Subversion bridge is the gateway drug to the DVCS world.</p>










<section data-type="sect3" data-pdf-bookmark="git svn" id="idp27437184">
<h3><code>git svn</code></h3>

<p>The base command in Git for all the Subversion bridging commands is <code>git svn</code>.
It takes quite a few commands, so we’ll show the most common while going through a few simple workflows.</p>

<p>It’s important to note that when you’re using <code>git svn</code>, you’re interacting with Subversion, which is a system that works very differently from Git.
Although you <strong>can</strong> do local branching and merging, it’s generally best to keep your history as linear as possible by rebasing your work, and avoiding doing things like simultaneously interacting with a Git remote repository.</p>

<p>Don’t rewrite your history and try to push again, and don’t push to a parallel Git repository to collaborate with fellow Git developers at the same time.
Subversion can have only a single linear history, and confusing it is very easy.
If you’re working with a team, and some are using SVN and others are using Git, make sure everyone is using the SVN server to collaborate – doing so will make your life easier.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Setting Up" id="idp27441888">
<h3>Setting Up</h3>

<p>To demonstrate this functionality, you need a typical SVN repository that you have write access to.
If you want to copy these examples, you’ll have to make a writeable copy of my test repository.
In order to do that easily, you can use a tool called <code>svnsync</code> that comes with Subversion.
For these tests, we created a new Subversion repository on Google Code that was a partial copy of the <code>protobuf</code> project, which is a tool that encodes structured data for network transmission.</p>

<p>To follow along, you first need to create a new local Subversion repository:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> mkdir /tmp/test-svn
<code class="gp">$</code> svnadmin create /tmp/test-svn</pre>

<p>Then, enable all users to change revprops – the easy way is to add a <code>pre-revprop-change</code> script that always exits 0:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> cat /tmp/test-svn/hooks/pre-revprop-change
<code class="gp">#</code>!/bin/sh
<code class="go">exit 0;</code>
<code class="gp">$</code> chmod +x /tmp/test-svn/hooks/pre-revprop-change</pre>

<p>You can now sync this project to your local machine by calling <code>svnsync init</code> with the to and from repositories.</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> svnsync init file:///tmp/test-svn <code class="se">\</code>
<code class="go">  http://progit-example.googlecode.com/svn/</code></pre>

<p>This sets up the properties to run the sync.
You can then clone the code by running</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> svnsync sync file:///tmp/test-svn
<code class="go">Committed revision 1.</code>
<code class="go">Copied properties for revision 1.</code>
<code class="go">Transmitting file data .............................[...]</code>
<code class="go">Committed revision 2.</code>
<code class="go">Copied properties for revision 2.</code>
<code class="go">[…]</code></pre>

<p>Although this operation may take only a few minutes, if you try to copy the original repository to another remote repository instead of a local one, the process will take nearly an hour, even though there are fewer than 100 commits.
Subversion has to clone one revision at a time and then push it back into another repository – it’s ridiculously inefficient, but it’s the only easy way to do this.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Getting Started" id="idp27442384">
<h3>Getting Started</h3>

<p>Now that you have a Subversion repository to which you have write access, you can go through a typical workflow.
You’ll start with the <code>git svn clone</code> command, which imports an entire Subversion repository into a local Git repository.
Remember that if you’re importing from a real hosted Subversion repository, you should replace the <code>file:///tmp/test-svn</code> here with the URL of your Subversion repository:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
<code class="go">Initialized empty Git repository in /private/tmp/progit/test-svn/.git/</code>
<code class="go">r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)</code>
<code class="go">    A	m4/acx_pthread.m4</code>
<code class="go">    A	m4/stl_hash.m4</code>
<code class="go">    A	java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java</code>
<code class="go">    A	java/src/test/java/com/google/protobuf/WireFormatTest.java</code>
<code class="go">…</code>
<code class="go">r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)</code>
<code class="go">Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/my-calc-branch, 75</code>
<code class="go">Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae</code>
<code class="go">Following parent with do_switch</code>
<code class="go">Successfully followed parent</code>
<code class="go">r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)</code>
<code class="go">Checked out HEAD:</code>
<code class="go">  file:///tmp/test-svn/trunk r75</code></pre>

<p>This runs the equivalent of two commands – <code>git svn init</code> followed by <code>git svn fetch</code> – on the URL you provide.
This can take a while.
The test project has only about 75 commits and the codebase isn’t that big, but Git has to check out each version, one at a time, and commit it individually.
For a project with hundreds or thousands of commits, this can literally take hours or even days to finish.</p>

<p>The <code>-T trunk -b branches -t tags</code> part tells Git that this Subversion repository follows the basic branching and tagging conventions.
If you name your trunk, branches, or tags differently, you can change these options.
Because this is so common, you can replace this entire part with <code>-s</code>, which means standard layout and implies all those options.
The following command is equivalent:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn clone file:///tmp/test-svn -s</pre>

<p>At this point, you should have a valid Git repository that has imported your branches and tags:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git branch -a
<code class="go">* master</code>
<code class="go">  remotes/origin/my-calc-branch</code>
<code class="go">  remotes/origin/tags/2.0.2</code>
<code class="go">  remotes/origin/tags/release-2.0.1</code>
<code class="go">  remotes/origin/tags/release-2.0.2</code>
<code class="go">  remotes/origin/tags/release-2.0.2rc1</code>
<code class="go">  remotes/origin/trunk</code></pre>

<p>Note how this tool manages Subversion tags as remote refs.
<a data-type="indexterm" data-primary="git commands" data-secondary="show-ref" id="idp27574032"/>
Let’s take a closer look with the Git plumbing command <code>show-ref</code>:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git show-ref
<code class="go">556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master</code>
<code class="go">0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch</code>
<code class="go">bfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2</code>
<code class="go">285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1</code>
<code class="go">cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2</code>
<code class="go">a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1</code>
<code class="go">556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk</code></pre>

<p>Git doesn’t do this when it clones from a Git server; here’s what a repository with tags looks like after a fresh clone:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git show-ref
<code class="go">c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master</code>
<code class="go">32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1</code>
<code class="go">75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2</code>
<code class="go">23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0</code>
<code class="go">7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0</code>
<code class="go">6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0</code></pre>

<p>Git fetches the tags directly into <code>refs/tags</code>, rather than treating them remote branches.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Committing Back to Subversion" id="idp27383600">
<h3>Committing Back to Subversion</h3>

<p>Now that you have a working repository, you can do some work on the project and push your commits back upstream, using Git effectively as a SVN client.
If you edit one of the files and commit it, you have a commit that exists in Git locally that doesn’t exist on the Subversion server:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git commit -am <code class="s1">'Adding git-svn instructions to the README'</code>
<code class="go">[master 4af61fd] Adding git-svn instructions to the README</code>
<code class="go"> 1 file changed, 5 insertions(+)</code></pre>

<p>Next, you need to push your change upstream.
Notice how this changes the way you work with Subversion – you can do several commits offline and then push them all at once to the Subversion server.
To push to a Subversion server, you run the <code>git svn dcommit</code> command:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn dcommit
<code class="go">Committing to file:///tmp/test-svn/trunk ...</code>
<code class="go">    M	README.txt</code>
<code class="go">Committed r77</code>
<code class="go">    M	README.txt</code>
<code class="go">r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)</code>
<code class="go">No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk</code>
<code class="go">Resetting to the latest refs/remotes/origin/trunk</code></pre>

<p>This takes all the commits you’ve made on top of the Subversion server code, does a Subversion commit for each, and then rewrites your local Git commit to include a unique identifier.
This is important because it means that all the SHA-1 checksums for your commits change.
Partly for this reason, working with Git-based remote versions of your projects concurrently with a Subversion server isn’t a good idea.
If you look at the last commit, you can see the new <code>git-svn-id</code> that was added:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log -1
<code class="go">commit 95e0222ba6399739834380eb10afcd73e0670bc5</code>
<code class="go">Author: ben &lt;ben@0b684db3-b064-4277-89d1-21af03df0a68&gt;</code>
<code class="go">Date:   Thu Jul 24 03:08:36 2014 +0000</code>

<code class="go">    Adding git-svn instructions to the README</code>

<code class="go">    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68</code></pre>

<p>Notice that the SHA-1 checksum that originally started with <code>4af61fd</code> when you committed now begins with <code>95e0222</code>.
If you want to push to both a Git server and a Subversion server, you have to push (<code>dcommit</code>) to the Subversion server first, because that action changes your commit data.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Pulling in New Changes" id="idp27631360">
<h3>Pulling in New Changes</h3>

<p>If you’re working with other developers, then at some point one of you will push, and then the other one will try to push a change that conflicts.
That change will be rejected until you merge in their work.
In <code>git svn</code>, it looks like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn dcommit
<code class="go">Committing to file:///tmp/test-svn/trunk ...</code>

<code class="go">ERROR from SVN:</code>
<code class="go">Transaction is out of date: File '/trunk/README.txt' is out of date</code>
<code class="go">W: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:</code>
<code class="go">:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M	README.txt</code>
<code class="go">Current branch master is up to date.</code>
<code class="go">ERROR: Not all changes have been committed into SVN, however the committed</code>
<code class="go">ones (if any) seem to be successfully integrated into the working tree.</code>
<code class="go">Please see the above messages for details.</code></pre>

<p>To resolve this situation, you can run <code>git svn rebase</code>, which pulls down any changes on the server that you don’t have yet and rebases any work you have on top of what is on the server:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn rebase
<code class="go">Committing to file:///tmp/test-svn/trunk ...</code>

<code class="go">ERROR from SVN:</code>
<code class="go">Transaction is out of date: File '/trunk/README.txt' is out of date</code>
<code class="go">W: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:</code>
<code class="go">:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M	README.txt</code>
<code class="go">First, rewinding head to replay your work on top of it...</code>
<code class="go">Applying: update foo</code>
<code class="go">Using index info to reconstruct a base tree...</code>
<code class="go">M	README.txt</code>
<code class="go">Falling back to patching base and 3-way merge...</code>
<code class="go">Auto-merging README.txt</code>
<code class="go">ERROR: Not all changes have been committed into SVN, however the committed</code>
<code class="go">ones (if any) seem to be successfully integrated into the working tree.</code>
<code class="go">Please see the above messages for details.</code></pre>

<p>Now, all your work is on top of what is on the Subversion server, so you can successfully <code>dcommit</code>:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn dcommit
<code class="go">Committing to file:///tmp/test-svn/trunk ...</code>
<code class="go">    M	README.txt</code>
<code class="go">Committed r85</code>
<code class="go">    M	README.txt</code>
<code class="go">r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)</code>
<code class="go">No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk</code>
<code class="go">Resetting to the latest refs/remotes/origin/trunk</code></pre>

<p>Note that unlike Git, which requires you to merge upstream work you don’t yet have locally before you can push, <code>git svn</code> makes you do that only if the changes conflict (much like how Subversion works).
If someone else pushes a change to one file and then you push a change to another file, your <code>dcommit</code> will work fine:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn dcommit
<code class="go">Committing to file:///tmp/test-svn/trunk ...</code>
<code class="go">    M	configure.ac</code>
<code class="go">Committed r87</code>
<code class="go">    M	autogen.sh</code>
<code class="go">r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)</code>
<code class="go">    M	configure.ac</code>
<code class="go">r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)</code>
<code class="go">W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:</code>
<code class="go">:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M	autogen.sh</code>
<code class="go">First, rewinding head to replay your work on top of it...</code></pre>

<p>This is important to remember, because the outcome is a project state that didn’t exist on either of your computers when you pushed.
If the changes are incompatible but don’t conflict, you may get issues that are difficult to diagnose.
This is different than using a Git server – in Git, you can fully test the state on your client system before publishing it, whereas in SVN, you can’t ever be certain that the states immediately before commit and after commit are identical.</p>

<p>You should also run this command to pull in changes from the Subversion server, even if you’re not ready to commit yourself.
You can run <code>git svn fetch</code> to grab the new data, but <code>git svn rebase</code> does the fetch and then updates your local commits.</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn rebase
<code class="go">    M	autogen.sh</code>
<code class="go">r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)</code>
<code class="go">First, rewinding head to replay your work on top of it...</code>
<code class="go">Fast-forwarded master to refs/remotes/origin/trunk.</code></pre>

<p>Running <code>git svn rebase</code> every once in a while makes sure your code is always up to date.
You need to be sure your working directory is clean when you run this, though.
If you have local changes, you must either stash your work or temporarily commit it before running <code>git svn rebase</code> – otherwise, the command will stop if it sees that the rebase will result in a merge conflict.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Git Branching Issues" id="idp27631952">
<h3>Git Branching Issues</h3>

<p>When you’ve become comfortable with a Git workflow, you’ll likely create topic branches, do work on them, and then merge them in.
If you’re pushing to a Subversion server via <code>git svn</code>, you may want to rebase your work onto a single branch each time instead of merging branches together.
The reason to prefer rebasing is that Subversion has a linear history and doesn’t deal with merges like Git does, so <code>git svn</code> follows only the first parent when converting the snapshots into Subversion commits.</p>

<p>Suppose your history looks like the following: you created an <code>experiment</code> branch, did two commits, and then merged them back into <code>master</code>.
When you <code>dcommit</code>, you see output like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn dcommit
<code class="go">Committing to file:///tmp/test-svn/trunk ...</code>
<code class="go">    M	CHANGES.txt</code>
<code class="go">Committed r89</code>
<code class="go">    M	CHANGES.txt</code>
<code class="go">r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)</code>
<code class="go">    M	COPYING.txt</code>
<code class="go">    M	INSTALL.txt</code>
<code class="go">Committed r90</code>
<code class="go">    M	INSTALL.txt</code>
<code class="go">    M	COPYING.txt</code>
<code class="go">r90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)</code>
<code class="go">No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk</code>
<code class="go">Resetting to the latest refs/remotes/origin/trunk</code></pre>

<p>Running <code>dcommit</code> on a branch with merged history works fine, except that when you look at your Git project history, it hasn’t rewritten either of the commits you made on the <code>experiment</code> branch – instead, all those changes appear in the SVN version of the single merge commit.</p>

<p>When someone else clones that work, all they see is the merge commit with all the work squashed into it, as though you ran <code>git merge --squash</code>; they don’t see the commit data about where it came from or when it was committed.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Subversion Branching" id="idp27879984">
<h3>Subversion Branching</h3>

<p>Branching in Subversion isn’t the same as branching in Git; if you can avoid using it much, that’s probably best.
However, you can create and commit to branches in Subversion using git svn.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Creating a New SVN Branch" id="idp27881744">
<h3>Creating a New SVN Branch</h3>

<p>To create a new branch in Subversion, you run <code>git svn branch [branchname]</code>:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn branch opera
<code class="go">Copying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...</code>
<code class="go">Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/opera, 90</code>
<code class="go">Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0</code>
<code class="go">Following parent with do_switch</code>
<code class="go">Successfully followed parent</code>
<code class="go">r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)</code></pre>

<p>This does the equivalent of the <code>svn copy trunk branches/opera</code> command in Subversion and operates on the Subversion server.
It’s important to note that it doesn’t check you out into that branch; if you commit at this point, that commit will go to <code>trunk</code> on the server, not <code>opera</code>.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Switching Active Branches" id="idp27931744">
<h3>Switching Active Branches</h3>

<p>Git figures out what branch your dcommits go to by looking for the tip of any of your Subversion branches in your history – you should have only one, and it should be the last one with a <code>git-svn-id</code> in your current branch history.</p>

<p>If you want to work on more than one branch simultaneously, you can set up local branches to <code>dcommit</code> to specific Subversion branches by starting them at the imported Subversion commit for that branch.
If you want an <code>opera</code> branch that you can work on separately, you can run</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git branch opera remotes/origin/opera</pre>

<p>Now, if you want to merge your <code>opera</code> branch into <code>trunk</code> (your <code>master</code> branch), you can do so with a normal <code>git merge</code>.
But you need to provide a descriptive commit message (via <code>-m</code>), or the merge will say “Merge branch opera” instead of something useful.</p>

<p>Remember that although you’re using <code>git merge</code> to do this operation, and the merge likely will be much easier than it would be in Subversion (because Git will automatically detect the appropriate merge base for you), this isn’t a normal Git merge commit.
You have to push this data back to a Subversion server that can’t handle a commit that tracks more than one parent; so, after you push it up, it will look like a single commit that squashed in all the work of another branch under a single commit.
After you merge one branch into another, you can’t easily go back and continue working on that branch, as you normally can in Git.
The <code>dcommit</code> command that you run erases any information that says what branch was merged in, so subsequent merge-base calculations will be wrong – the dcommit makes your <code>git merge</code> result look like you ran <code>git merge --squash</code>.
Unfortunately, there’s no good way to avoid this situation – Subversion can’t store this information, so you’ll always be crippled by its limitations while you’re using it as your server.
To avoid issues, you should delete the local branch (in this case, <code>opera</code>) after you merge it into trunk.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Subversion Commands" id="idp27943280">
<h3>Subversion Commands</h3>

<p>The <code>git svn</code> toolset provides a number of commands to help ease the transition to Git by providing some functionality that’s similar to what you had in Subversion.
Here are a few commands that give you what Subversion used to.</p>












<section data-type="sect4" data-pdf-bookmark="SVN Style History" id="idp27992352">
<h4>SVN Style History</h4>

<p>If you’re used to Subversion and want to see your history in SVN output style, you can run <code>git svn log</code> to view your commit history in SVN formatting:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn log
<code class="go">------------------------------------------------------------------------</code>
<code class="go">r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines</code>

<code class="go">autogen change</code>

<code class="go">------------------------------------------------------------------------</code>
<code class="go">r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines</code>

<code class="go">Merge branch 'experiment'</code>

<code class="go">------------------------------------------------------------------------</code>
<code class="go">r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines</code>

<code class="go">updated the changelog</code></pre>

<p>You should know two important things about <code>git svn log</code>.
First, it works offline, unlike the real <code>svn log</code> command, which asks the Subversion server for the data.
Second, it only shows you commits that have been committed up to the Subversion server.
Local Git commits that you haven’t dcommited don’t show up; neither do commits that people have made to the Subversion server in the meantime.
It’s more like the last known state of the commits on the Subversion server.</p>
</section>













<section data-type="sect4" data-pdf-bookmark="SVN Annotation" id="idp28081088">
<h4>SVN Annotation</h4>

<p>Much as the <code>git svn log</code> command simulates the <code>svn log</code> command offline, you can get the equivalent of <code>svn annotate</code> by running <code>git svn blame [FILE]</code>.
The output looks like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn blame README.txt
<code class="go"> 2   temporal Protocol Buffers - Google's data interchange format</code>
<code class="go"> 2   temporal Copyright 2008 Google Inc.</code>
<code class="go"> 2   temporal http://code.google.com/apis/protocolbuffers/</code>
<code class="go"> 2   temporal</code>
<code class="go">22   temporal C++ Installation - Unix</code>
<code class="go">22   temporal =======================</code>
<code class="go"> 2   temporal</code>
<code class="go">79    schacon Committing in git-svn.</code>
<code class="go">78    schacon</code>
<code class="go"> 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol</code>
<code class="go"> 2   temporal Buffer compiler (protoc) execute the following:</code>
<code class="go"> 2   temporal</code></pre>

<p>Again, it doesn’t show commits that you did locally in Git or that have been pushed to Subversion in the meantime.</p>
</section>













<section data-type="sect4" data-pdf-bookmark="SVN Server Information" id="idp28055504">
<h4>SVN Server Information</h4>

<p>You can also get the same sort of information that <code>svn info</code> gives you by running <code>git svn info</code>:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn info
<code class="go">Path: .</code>
<code class="go">URL: https://schacon-test.googlecode.com/svn/trunk</code>
<code class="go">Repository Root: https://schacon-test.googlecode.com/svn</code>
<code class="go">Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029</code>
<code class="go">Revision: 87</code>
<code class="go">Node Kind: directory</code>
<code class="go">Schedule: normal</code>
<code class="go">Last Changed Author: schacon</code>
<code class="go">Last Changed Rev: 87</code>
<code class="go">Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)</code></pre>

<p>This is like <code>blame</code> and <code>log</code> in that it runs offline and is up to date only as of the last time you communicated with the Subversion server.</p>
</section>













<section data-type="sect4" data-pdf-bookmark="Ignoring What Subversion Ignores" id="idp28178880">
<h4>Ignoring What Subversion Ignores</h4>

<p>If you clone a Subversion repository that has <code>svn:ignore</code> properties set anywhere, you’ll likely want to set corresponding <code>.gitignore</code> files so you don’t accidentally commit files that you shouldn’t.
<code>git svn</code> has two commands to help with this issue.
The first is <code>git svn create-ignore</code>, which automatically creates corresponding <code>.gitignore</code> files for you so your next commit can include them.</p>

<p>The second command is <code>git svn show-ignore</code>, which prints to stdout the lines you need to put in a <code>.gitignore</code> file so you can redirect the output into your project exclude file:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn show-ignore &gt; .git/info/exclude</pre>

<p>That way, you don’t litter the project with <code>.gitignore</code> files.
This is a good option if you’re the only Git user on a Subversion team, and your teammates don’t want <code>.gitignore</code> files in the project.</p>
</section>

</section>













<section data-type="sect3" data-pdf-bookmark="Git-Svn Summary" id="idp27943616">
<h3>Git-Svn Summary</h3>

<p>The <code>git svn</code> tools are useful if you’re stuck with a Subversion server, or are otherwise in a development environment that necessitates running a Subversion server.
You should consider it crippled Git, however, or you’ll hit issues in translation that may confuse you and your collaborators.
To stay out of trouble, try to follow these guidelines:</p>

<ul>
<li>
<p>Keep a linear Git history that doesn’t contain merge commits made by <code>git merge</code>.
Rebase any work you do outside of your mainline branch back onto it; don’t merge it in.</p>
</li>
<li>
<p>Don’t set up and collaborate on a separate Git server.
Possibly have one to speed up clones for new developers, but don’t push anything to it that doesn’t have a <code>git-svn-id</code> entry.
You may even want to add a <code>pre-receive</code> hook that checks each commit message for a <code>git-svn-id</code> and rejects pushes that contain commits without it.</p>
</li>
</ul>

<p>If you follow those guidelines, working with a Subversion server can be more bearable.
However, if it’s possible to move to a real Git server, doing so can gain your team a lot more.</p>
</section>



</section>













<section data-type="sect2" data-pdf-bookmark="Git and Mercurial" id="idp27430192">
<h2>Git and Mercurial</h2>

<p><a data-type="indexterm" data-primary="Interoperation with other VCSs" data-secondary="Mercurial" id="idp28110912"/>
<a data-type="indexterm" data-primary="Mercurial" id="idp28111984"/>
The DVCS universe is larger than just Git.
In fact, there are many other systems in this space, each with their own angle on how to do distributed version control correctly.
Apart from Git, the most popular is Mercurial, and the two are very similar in many respects.</p>

<p>The good news, if you prefer Git’s client-side behavior but are working with a project whose source code is controlled with Mercurial, is that there’s a way to use Git as a client for a Mercurial-hosted repository.
Since the way Git talks to server repositories is through remotes, it should come as no surprise that this bridge is implemented as a remote helper.
The project’s name is git-remote-hg, and it can be found at <a href="https://github.com/felipec/git-remote-hg"><em class="hyperlink">https://github.com/felipec/git-remote-hg</em></a>.</p>










<section data-type="sect3" data-pdf-bookmark="git-remote-hg" id="idp28115216">
<h3>git-remote-hg</h3>

<p>First, you need to install git-remote-hg.
This basically entails dropping its file somewhere in your path, like so:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> curl -o ~/bin/git-remote-hg <code class="se">\</code>
<code class="go">  https://raw.githubusercontent.com/felipec/git-remote-hg/master/git-remote-hg</code>
<code class="gp">$</code> chmod +x ~/bin/git-remote-hg</pre>

<p>…assuming <code>~/bin</code> is in your <code>$PATH</code>.
Git-remote-hg has one other dependency: the <code>mercurial</code> library for Python.
If you have Python installed, this is as simple as:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> pip install mercurial</pre>

<p>(If you don’t have Python installed, visit <a href="https://www.python.org/"><em class="hyperlink">https://www.python.org/</em></a> and get it first.)</p>

<p>The last thing you’ll need is the Mercurial client.
Go to <a href="http://mercurial.selenic.com/"><em class="hyperlink">http://mercurial.selenic.com/</em></a> and install it if you haven’t already.</p>

<p>Now you’re ready to rock.
All you need is a Mercurial repository you can push to.
Fortunately, every Mercurial repository can act this way, so we’ll just use the “hello world” repository everyone uses to learn Mercurial:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> hg clone http://selenic.com/repo/hello /tmp/hello</pre>
</section>













<section data-type="sect3" data-pdf-bookmark="Getting Started" id="idp28216736">
<h3>Getting Started</h3>

<p>Now that we have a suitable “server-side” repository, we can go through a typical workflow.
As you’ll see, these two systems are similar enough that there isn’t much friction.</p>

<p>As always with Git, first we clone:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git clone hg::/tmp/hello /tmp/hello-git
<code class="gp">$</code> <code class="nb">cd</code> /tmp/hello-git
<code class="gp">$</code> git log --oneline --graph --decorate
<code class="go">* ac7955c (HEAD, origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master, master) Create a makefile</code>
<code class="go">* 65bb417 Create a standard "hello, world" program</code></pre>

<p>You’ll notice that working with a Mercurial repository uses the standard <code>git clone</code> command.
That’s because git-remote-hg is working at a fairly low level, using a similar mechanism to how Git’s HTTP/S protocol is implemented (remote helpers).
Since Git and Mercurial are both designed for every client to have a full copy of the repository history, this command makes a full clone, including all the project’s history, and does it fairly quickly.</p>

<p>The log command shows two commits, the latest of which is pointed to by a whole slew of refs.
It turns out some of these aren’t actually there.
Let’s take a look at what’s actually in the <code>.git</code> directory:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> tree .git/refs
<code class="go">.git/refs</code>
<code class="go">├── heads</code>
<code class="go">│   └── master</code>
<code class="go">├── hg</code>
<code class="go">│   └── origin</code>
<code class="go">│       ├── bookmarks</code>
<code class="go">│       │   └── master</code>
<code class="go">│       └── branches</code>
<code class="go">│           └── default</code>
<code class="go">├── notes</code>
<code class="go">│   └── hg</code>
<code class="go">├── remotes</code>
<code class="go">│   └── origin</code>
<code class="go">│       └── HEAD</code>
<code class="go">└── tags</code>

<code class="go">9 directories, 5 files</code></pre>

<p>Git-remote-hg is trying to make things more idiomatically Git-esque, but under the hood it’s managing the conceptual mapping between two slightly different systems.
The <code>refs/hg</code> directory is where the actual remote refs are stored.
For example, the <code>refs/hg/origin/branches/default</code> is a Git ref file that contains the SHA-1 starting with “ac7955c”, which is the commit that <code>master</code> points to.
So the <code>refs/hg</code> directory is kind of like a fake <code>refs/remotes/origin</code>, but it has the added distinction between bookmarks and branches.</p>

<p>The <code>notes/hg</code> file is the starting point for how git-remote-hg maps Git commit hashes to Mercurial changeset IDs.
Let’s explore a bit:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> cat notes/hg
<code class="go">d4c10386...</code>

<code class="gp">$</code> git cat-file -p d4c10386...
<code class="go">tree 1781c96...</code>
<code class="go">author remote-hg &lt;&gt; 1408066400 -0800</code>
<code class="go">committer remote-hg &lt;&gt; 1408066400 -0800</code>

<code class="go">Notes for master</code>

<code class="gp">$</code> git ls-tree 1781c96...
<code class="go">100644 blob ac9117f...	65bb417...</code>
<code class="go">100644 blob 485e178...	ac7955c...</code>

<code class="gp">$</code> git cat-file -p ac9117f
<code class="go">0a04b987be5ae354b710cefeba0e2d9de7ad41a9</code></pre>

<p>So <code>refs/notes/hg</code> points to a tree, which in the Git object database is a list of other objects with names.
<code>git ls-tree</code> outputs the mode, type, object hash, and filename for items inside a tree.
Once we dig down to one of the tree items, we find that inside it is a blob named “ac9117f” (the SHA-1 hash of the commit pointed to by <code>master</code>), with contents “0a04b98” (which is the ID of the Mercurial changeset at the tip of the <code>default</code> branch).</p>

<p>The good news is that we mostly don’t have to worry about all of this.
The typical workflow won’t be very different from working with a Git remote.</p>

<p>There’s one more thing we should attend to before we continue: ignores.
Mercurial and Git use a very similar mechanism for this, but it’s likely you don’t want to actually commit a <code>.gitignore</code> file into a Mercurial repository.
Fortunately, Git has a way to ignore files that’s local to an on-disk repository, and the Mercurial format is compatible with Git, so you just have to copy it over:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> cp .hgignore .git/info/exclude</pre>

<p>The <code>.git/info/exclude</code> file acts just like a <code>.gitignore</code>, but isn’t included in commits.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Workflow" id="idp28221312">
<h3>Workflow</h3>

<p>Let’s assume we’ve done some work and made some commits on the <code>master</code> branch, and you’re ready to push it to the remote repository.
Here’s what our repository looks like right now:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log --oneline --graph --decorate
<code class="go">* ba04a2a (HEAD, master) Update makefile</code>
<code class="go">* d25d16f Goodbye</code>
<code class="go">* ac7955c (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Create a makefile</code>
<code class="go">* 65bb417 Create a standard "hello, world" program</code></pre>

<p>Our <code>master</code> branch is two commits ahead of <code>origin/master</code>, but those two commits exist only on our local machine.
Let’s see if anyone else has been doing important work at the same time:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git fetch
<code class="go">From hg::/tmp/hello</code>
<code class="go">   ac7955c..df85e87  master     -&gt; origin/master</code>
<code class="go">   ac7955c..df85e87  branches/default -&gt; origin/branches/default</code>
<code class="gp">$</code> git log --oneline --graph --decorate --all
<code class="go">* 7b07969 (refs/notes/hg) Notes for default</code>
<code class="go">* d4c1038 Notes for master</code>
<code class="go">* df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation</code>
<code class="go">| * ba04a2a (HEAD, master) Update makefile</code>
<code class="go">| * d25d16f Goodbye</code>
<code class="go">|/</code>
<code class="go">* ac7955c Create a makefile</code>
<code class="go">* 65bb417 Create a standard "hello, world" program</code></pre>

<p>Since we used the <code>--all</code> flag, we see the “notes” refs that are used internally by git-remote-hg, but we can ignore them.
The rest is what we expected; <code>origin/master</code> has advanced by one commit, and our history has now diverged.
Unlike the other systems we work with in this chapter, Mercurial is capable of handling merges, so we’re not going to do anything fancy.</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git merge origin/master
<code class="go">Auto-merging hello.c</code>
<code class="go">Merge made by the 'recursive' strategy.</code>
<code class="go"> hello.c | 2 +-</code>
<code class="go"> 1 file changed, 1 insertion(+), 1 deletion(-)</code>
<code class="gp">$</code> git log --oneline --graph --decorate
<code class="go">*   0c64627 (HEAD, master) Merge remote-tracking branch 'origin/master'</code>
<code class="go">|\</code>
<code class="go">| * df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation</code>
<code class="go">* | ba04a2a Update makefile</code>
<code class="go">* | d25d16f Goodbye</code>
<code class="go">|/</code>
<code class="go">* ac7955c Create a makefile</code>
<code class="go">* 65bb417 Create a standard "hello, world" program</code></pre>

<p>Perfect.
We run the tests and everything passes, so we’re ready to share our work with the rest of the team:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git push
<code class="go">To hg::/tmp/hello</code>
<code class="go">   df85e87..0c64627  master -&gt; master</code></pre>

<p>That’s it!
If you take a look at the Mercurial repository, you’ll see that this did what we’d expect:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> hg log -G --style compact
<code class="go">o    5[tip]:4,2   dc8fa4f932b8   2014-08-14 19:33 -0700   ben</code>
<code class="go">|\     Merge remote-tracking branch 'origin/master'</code>
<code class="go">| |</code>
<code class="go">| o  4   64f27bcefc35   2014-08-14 19:27 -0700   ben</code>
<code class="go">| |    Update makefile</code>
<code class="go">| |</code>
<code class="go">| o  3:1   4256fc29598f   2014-08-14 19:27 -0700   ben</code>
<code class="go">| |    Goodbye</code>
<code class="go">| |</code>
<code class="go">@ |  2   7db0b4848b3c   2014-08-14 19:30 -0700   ben</code>
<code class="go">|/     Add some documentation</code>
<code class="go">|</code>
<code class="go">o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm</code>
<code class="go">|    Create a makefile</code>
<code class="go">|</code>
<code class="go">o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm</code>
<code class="go">     Create a standard "hello, world" program</code></pre>

<p>The changeset numbered <em>2</em> was made by Mercurial, and the changesets numbered <em>3</em> and <em>4</em> were made by git-remote-hg, by pushing commits made with Git.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Branches and Bookmarks" id="idp28322368">
<h3>Branches and Bookmarks</h3>

<p>Git has only one kind of branch: a reference that moves when commits are made.
In Mercurial, this kind of a reference is called a “bookmark,” and it behaves in much the same way as a Git branch.</p>

<p>Mercurial’s concept of a “branch” is more heavyweight.
The branch that a changeset is made on is recorded <em>with the changeset</em>, which means it will always be in the repository history.
Here’s an example of a commit that was made on the <code>develop</code> branch:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> hg log -l 1
<code class="go">changeset:   6:8f65e5e02793</code>
<code class="go">branch:      develop</code>
<code class="go">tag:         tip</code>
<code class="go">user:        Ben Straub &lt;ben@straub.cc&gt;</code>
<code class="go">date:        Thu Aug 14 20:06:38 2014 -0700</code>
<code class="go">summary:     More documentation</code></pre>

<p>Note the line that begins with “branch”.
Git can’t really replicate this (and doesn’t need to; both types of branch can be represented as a Git ref), but git-remote-hg needs to understand the difference, because Mercurial cares.</p>

<p>Creating Mercurial bookmarks is as easy as creating Git branches.
On the Git side:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git checkout -b featureA
<code class="go">Switched to a new branch 'featureA'</code>
<code class="gp">$</code> git push origin featureA
<code class="go">To hg::/tmp/hello</code>
<code class="go"> * [new branch]      featureA -&gt; featureA</code></pre>

<p>That’s all there is to it.
On the Mercurial side, it looks like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> hg bookmarks
<code class="go">   featureA                  5:bd5ac26f11f9</code>
<code class="gp">$</code> hg log --style compact -G
<code class="go">@  6[tip]   8f65e5e02793   2014-08-14 20:06 -0700   ben</code>
<code class="go">|    More documentation</code>
<code class="go">|</code>
<code class="go">o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben</code>
<code class="go">|\     Merge remote-tracking branch 'origin/master'</code>
<code class="go">| |</code>
<code class="go">| o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben</code>
<code class="go">| |    update makefile</code>
<code class="go">| |</code>
<code class="go">| o  3:1   318914536c86   2014-08-14 20:00 -0700   ben</code>
<code class="go">| |    goodbye</code>
<code class="go">| |</code>
<code class="go">o |  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben</code>
<code class="go">|/     Add some documentation</code>
<code class="go">|</code>
<code class="go">o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm</code>
<code class="go">|    Create a makefile</code>
<code class="go">|</code>
<code class="go">o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm</code>
<code class="go">     Create a standard "hello, world" program</code></pre>

<p>Note the new <code>[featureA]</code> tag on revision 5.
These act exactly like Git branches on the Git side, with one exception: you can’t delete a bookmark from the Git side (this is a limitation of remote helpers).</p>

<p>You can work on a “heavyweight” Mercurial branch also: just put a branch in the <code>branches</code> namespace:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git checkout -b branches/permanent
<code class="go">Switched to a new branch 'branches/permanent'</code>
<code class="gp">$</code> vi Makefile
<code class="gp">$</code> git commit -am <code class="s1">'A permanent change'</code>
<code class="gp">$</code> git push origin branches/permanent
<code class="go">To hg::/tmp/hello</code>
<code class="go"> * [new branch]      branches/permanent -&gt; branches/permanent</code></pre>

<p>Here’s what that looks like on the Mercurial side:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> hg branches
<code class="go">permanent                      7:a4529d07aad4</code>
<code class="go">develop                        6:8f65e5e02793</code>
<code class="go">default                        5:bd5ac26f11f9 (inactive)</code>
<code class="gp">$</code> hg log -G
<code class="go">o  changeset:   7:a4529d07aad4</code>
<code class="go">|  branch:      permanent</code>
<code class="go">|  tag:         tip</code>
<code class="go">|  parent:      5:bd5ac26f11f9</code>
<code class="go">|  user:        Ben Straub &lt;ben@straub.cc&gt;</code>
<code class="go">|  date:        Thu Aug 14 20:21:09 2014 -0700</code>
<code class="go">|  summary:     A permanent change</code>
<code class="go">|</code>
<code class="go">| @  changeset:   6:8f65e5e02793</code>
<code class="go">|/   branch:      develop</code>
<code class="go">|    user:        Ben Straub &lt;ben@straub.cc&gt;</code>
<code class="go">|    date:        Thu Aug 14 20:06:38 2014 -0700</code>
<code class="go">|    summary:     More documentation</code>
<code class="go">|</code>
<code class="go">o    changeset:   5:bd5ac26f11f9</code>
<code class="go">|\   bookmark:    featureA</code>
<code class="go">| |  parent:      4:0434aaa6b91f</code>
<code class="go">| |  parent:      2:f098c7f45c4f</code>
<code class="go">| |  user:        Ben Straub &lt;ben@straub.cc&gt;</code>
<code class="go">| |  date:        Thu Aug 14 20:02:21 2014 -0700</code>
<code class="go">| |  summary:     Merge remote-tracking branch 'origin/master'</code>
<code class="go">[...]</code></pre>

<p>The branch name “permanent” was recorded with the changeset marked <em>7</em>.</p>

<p>From the Git side, working with either of these branch styles is the same: just checkout, commit, fetch, merge, pull, and push as you normally would.
One thing you should know is that Mercurial doesn’t support rewriting history, only adding to it.
Here’s what our Mercurial repository looks like after an interactive rebase and a force-push:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> hg log --style compact -G
<code class="go">o  10[tip]   99611176cbc9   2014-08-14 20:21 -0700   ben</code>
<code class="go">|    A permanent change</code>
<code class="go">|</code>
<code class="go">o  9   f23e12f939c3   2014-08-14 20:01 -0700   ben</code>
<code class="go">|    Add some documentation</code>
<code class="go">|</code>
<code class="go">o  8:1   c16971d33922   2014-08-14 20:00 -0700   ben</code>
<code class="go">|    goodbye</code>
<code class="go">|</code>
<code class="go">| o  7:5   a4529d07aad4   2014-08-14 20:21 -0700   ben</code>
<code class="go">| |    A permanent change</code>
<code class="go">| |</code>
<code class="go">| | @  6   8f65e5e02793   2014-08-14 20:06 -0700   ben</code>
<code class="go">| |/     More documentation</code>
<code class="go">| |</code>
<code class="go">| o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben</code>
<code class="go">| |\     Merge remote-tracking branch 'origin/master'</code>
<code class="go">| | |</code>
<code class="go">| | o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben</code>
<code class="go">| | |    update makefile</code>
<code class="go">| | |</code>
<code class="go">+---o  3:1   318914536c86   2014-08-14 20:00 -0700   ben</code>
<code class="go">| |      goodbye</code>
<code class="go">| |</code>
<code class="go">| o  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben</code>
<code class="go">|/     Add some documentation</code>
<code class="go">|</code>
<code class="go">o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm</code>
<code class="go">|    Create a makefile</code>
<code class="go">|</code>
<code class="go">o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm</code>
<code class="go">     Create a standard "hello, world" program</code></pre>

<p>Changesets <em>8</em>, <em>9</em>, and <em>10</em> have been created and belong to the <code>permanent</code> branch, but the old changesets are still there.
This can be <strong>very</strong> confusing for your teammates who are using Mercurial, so try to avoid it.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Mercurial Summary" id="idp28495120">
<h3>Mercurial Summary</h3>

<p>Git and Mercurial are similar enough that working across the boundary is fairly painless.
If you avoid changing history that’s left your machine (as is generally recommended), you may not even be aware that the other end is Mercurial.</p>
</section>



</section>













<section data-type="sect2" data-pdf-bookmark="Git and Perforce" id="idp28946448">
<h2>Git and Perforce</h2>

<p><a data-type="indexterm" data-primary="Interoperation with other VCSs" data-secondary="Perforce" id="idp28947888"/>
<a data-type="indexterm" data-primary="Perforce" id="idp28948960"/>
Perforce is a very popular version-control system in corporate environments.
It’s been around since 1995, which makes it the oldest system covered in this chapter.
As such, it’s designed with the constraints of its day; it assumes you’re always connected to a single central server, and only one version is kept on the local disk.
To be sure, its features and constraints are well-suited to several specific problems, but there are lots of projects using Perforce where Git would actually work better.</p>

<p>There are two options if you’d like to mix your use of Perforce and Git.
The first one we’ll cover is the “Git Fusion” bridge from the makers of Perforce, which lets you expose subtrees of your Perforce depot as read-write Git repositories.
The second is git-p4, a client-side bridge that lets you use Git as a Perforce client, without requiring any reconfiguration of the Perforce server.</p>










<section data-type="sect3" data-pdf-bookmark="Git Fusion" id="_p4_git_fusion">
<h3>Git Fusion</h3>

<p><a data-type="indexterm" data-primary="Perforce" data-secondary="Git Fusion" id="idp28952960"/>
Perforce provides a product called Git Fusion (available at <a href="http://www.perforce.com/git-fusion"><em class="hyperlink">http://www.perforce.com/git-fusion</em></a>), which synchronizes a Perforce server with Git repositories on the server side.</p>












<section data-type="sect4" data-pdf-bookmark="Setting Up" id="idp28955296">
<h4>Setting Up</h4>

<p>For our examples, we’ll be using the easiest installation method for Git Fusion, which is downloading a virtual machine that runs the Perforce daemon and Git Fusion.
You can get the virtual machine image from <a href="http://www.perforce.com/downloads/Perforce/20-User"><em class="hyperlink">http://www.perforce.com/downloads/Perforce/20-User</em></a>, and once it’s finished downloading, import it into your favorite virtualization software (we’ll use VirtualBox).</p>

<p>Upon first starting the machine, it asks you to customize the password for three Linux users (<code>root</code>, <code>perforce</code>, and <code>git</code>), and provide an instance name, which can be used to distinguish this installation from others on the same network. When that has all completed, you’ll see this:</p>

<figure><div class="border-box"><img src="book/09-git-and-other-scms/images/git-fusion-boot.png" alt="The Git Fusion virtual machine boot screen."/></div><figcaption>The Git Fusion virtual machine boot screen.</figcaption></figure>

<p>You should take note of the IP address that’s shown here, we’ll be using it later on.
Next, we’ll create a Perforce user.
Select the “Login” option at the bottom and press enter (or SSH to the machine), and log in as <code>root</code>.
Then use these commands to create a user:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> p4 -p localhost:1666 -u super user -f john
<code class="gp">$</code> p4 -p localhost:1666 -u john passwd
<code class="gp">$</code> <code class="nb">exit</code></pre>

<p>The first one will open a VI editor to customize the user, but you can accept the defaults by typing <code>:wq</code> and hitting enter.
The second one will prompt you to enter a password twice.
That’s all we need to do with a shell prompt, so exit out of the session.</p>

<p>The next thing you’ll need to do to follow along is to tell Git not to verify SSL certificates.
The Git Fusion image comes with a certificate, but it’s for a domain that won’t match your virtual machine’s IP address, so Git will reject the HTTPS connection.
If this is going to be a permanent installation, consult the Perforce Git Fusion manual to install a different certificate; for our example purposes, this will suffice:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">export </code><code class="nv">GIT_SSL_NO_VERIFY</code><code class="o">=</code><code class="nb">true</code></pre>

<p>Now we can test that everything is working.</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git clone https://10.0.1.254/Talkhouse
<code class="go">Cloning into 'Talkhouse'...</code>
<code class="go">Username for 'https://10.0.1.254': john</code>
<code class="go">Password for 'https://john@10.0.1.254':</code>
<code class="go">remote: Counting objects: 630, done.</code>
<code class="go">remote: Compressing objects: 100% (581/581), done.</code>
<code class="go">remote: Total 630 (delta 172), reused 0 (delta 0)</code>
<code class="go">Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.</code>
<code class="go">Resolving deltas: 100% (172/172), done.</code>
<code class="go">Checking connectivity... done.</code></pre>

<p>The virtual-machine image comes equipped with a sample project that you can clone.
Here we’re cloning over HTTPS, with the <code>john</code> user that we created above; Git asks for credentials for this connection, but the credential cache will allow us to skip this step for any subsequent requests.</p>
</section>













<section data-type="sect4" data-pdf-bookmark="Fusion Configuration" id="idp28955888">
<h4>Fusion Configuration</h4>

<p>Once you’ve got Git Fusion installed, you’ll want to tweak the configuration.
This is actually fairly easy to do using your favorite Perforce client; just map the <code>//.git-fusion</code> directory on the Perforce server into your workspace.
The file structure looks like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> tree
<code class="go">.</code>
<code class="go">├── objects</code>
<code class="go">│   ├── repos</code>
<code class="go">│   │   └── [...]</code>
<code class="go">│   └── trees</code>
<code class="go">│       └── [...]</code>
<code class="go">│</code>
<code class="go">├── p4gf_config</code>
<code class="go">├── repos</code>
<code class="go">│   └── Talkhouse</code>
<code class="go">│       └── p4gf_config</code>
<code class="go">└── users</code>
<code class="go">    └── p4gf_usermap</code>

<code class="go">498 directories, 287 files</code></pre>

<p>The <code>objects</code> directory is used internally by Git Fusion to map Perforce objects to Git and vice versa, you won’t have to mess with anything in there.
There’s a global <code>p4gf_config</code> file in this directory, as well as one for each repository – these are the configuration files that determine how Git Fusion behaves.
Let’s take a look at the file in the root:</p>

<pre data-type="programlisting" data-code-language="ini"><code class="k">[repo-creation]</code>
<code class="na">charset</code> <code class="o">=</code> <code class="s">utf8</code>

<code class="k">[git-to-perforce]</code>
<code class="na">change-owner</code> <code class="o">=</code> <code class="s">author</code>
<code class="na">enable-git-branch-creation</code> <code class="o">=</code> <code class="s">yes</code>
<code class="na">enable-swarm-reviews</code> <code class="o">=</code> <code class="s">yes</code>
<code class="na">enable-git-merge-commits</code> <code class="o">=</code> <code class="s">yes</code>
<code class="na">enable-git-submodules</code> <code class="o">=</code> <code class="s">yes</code>
<code class="na">preflight-commit</code> <code class="o">=</code> <code class="s">none</code>
<code class="na">ignore-author-permissions</code> <code class="o">=</code> <code class="s">no</code>
<code class="na">read-permission-check</code> <code class="o">=</code> <code class="s">none</code>
<code class="na">git-merge-avoidance-after-change-num</code> <code class="o">=</code> <code class="s">12107</code>

<code class="k">[perforce-to-git]</code>
<code class="na">http-url</code> <code class="o">=</code> <code class="s">none</code>
<code class="na">ssh-url</code> <code class="o">=</code> <code class="s">none</code>

<code class="k">[@features]</code>
<code class="na">imports</code> <code class="o">=</code> <code class="s">False</code>
<code class="na">chunked-push</code> <code class="o">=</code> <code class="s">False</code>
<code class="na">matrix2</code> <code class="o">=</code> <code class="s">False</code>
<code class="na">parallel-push</code> <code class="o">=</code> <code class="s">False</code>

<code class="k">[authentication]</code>
<code class="na">email-case-sensitivity</code> <code class="o">=</code> <code class="s">no</code></pre>

<p>We won’t go into the meanings of these flags here, but note that this is just an INI-formatted text file, much like Git uses for configuration.
This file specifies the global options, which can then be overridden by repository-specific configuration files, like <code>repos/Talkhouse/p4gf_config</code>.
If you open this file, you’ll see a <code>[@repo]</code> section with some settings that are different from the global defaults.
You’ll also see sections that look like this:</p>

<pre data-type="programlisting" data-code-language="ini"><code class="k">[Talkhouse-master]</code>
<code class="na">git-branch-name</code> <code class="o">=</code> <code class="s">master</code>
<code class="na">view</code> <code class="o">=</code> <code class="s">//depot/Talkhouse/main-dev/... ...</code></pre>

<p>This is a mapping between a Perforce branch and a Git branch.
The section can be named whatever you like, so long as the name is unique.
<code>git-branch-name</code> lets you convert a depot path that would be cumbersome under Git to a more friendly name.
The <code>view</code> setting controls how Perforce files are mapped into the Git repository, using the standard view mapping syntax.
More than one mapping can be specified, like in this example:</p>

<pre data-type="programlisting" data-code-language="ini"><code class="k">[multi-project-mapping]</code>
<code class="na">git-branch-name</code> <code class="o">=</code> <code class="s">master</code>
<code class="na">view</code> <code class="o">=</code> <code class="s">//depot/project1/main/... project1/...</code>
<code class="s">       //depot/project2/mainline/... project2/...</code></pre>

<p>This way, if your normal workspace mapping includes changes in the structure of the directories, you can replicate that with a Git repository.</p>

<p>The last file we’ll discuss is <code>users/p4gf_usermap</code>, which maps Perforce users to Git users, and which you may not even need.
When converting from a Perforce changeset to a Git commit, Git Fusion’s default behavior is to look up the Perforce user, and use the email address and full name stored there for the author/committer field in Git.
When converting the other way, the default is to look up the Perforce user with the email address stored in the Git commit’s author field, and submit the changeset as that user (with permissions applying).
In most cases, this behavior will do just fine, but consider the following mapping file:</p>

<pre data-type="programlisting">john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"</pre>

<p>Each line is of the format <code>&lt;user&gt; &lt;email&gt; "&lt;full name&gt;"</code>, and creates a single user mapping.
The first two lines map two distinct email addresses to the same Perforce user account.
This is useful if you’ve created Git commits under several different email addresses (or change email addresses), but want them to be mapped to the same Perforce user.
When creating a Git commit from a Perforce changeset, the first line matching the Perforce user is used for Git authorship information.</p>

<p>The last two lines mask Bob and Joe’s actual names and email addresses from the Git commits that are created.
This is nice if you want to open-source an internal project, but don’t want to publish your employee directory to the entire world.
Note that the email addresses and full names should be unique, unless you want all the Git commits to be attributed to a single fictional author.</p>
</section>













<section data-type="sect4" data-pdf-bookmark="Workflow" id="idp29159520">
<h4>Workflow</h4>

<p>Perforce Git Fusion is a two-way bridge between Perforce and Git version control.
Let’s have a look at how it feels to work from the Git side.
We’ll assume we’ve mapped in the “Jam” project using a configuration file as shown above, which we can clone like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git clone https://10.0.1.254/Jam
<code class="go">Cloning into 'Jam'...</code>
<code class="go">Username for 'https://10.0.1.254': john</code>
<code class="go">Password for 'https://ben@10.0.1.254':</code>
<code class="go">remote: Counting objects: 2070, done.</code>
<code class="go">remote: Compressing objects: 100% (1704/1704), done.</code>
<code class="go">Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.</code>
<code class="go">remote: Total 2070 (delta 1242), reused 0 (delta 0)</code>
<code class="go">Resolving deltas: 100% (1242/1242), done.</code>
<code class="go">Checking connectivity... done.</code>
<code class="gp">$</code> git branch -a
<code class="go">* master</code>
<code class="go">  remotes/origin/HEAD -&gt; origin/master</code>
<code class="go">  remotes/origin/master</code>
<code class="go">  remotes/origin/rel2.1</code>
<code class="gp">$</code> git log --oneline --decorate --graph --all
<code class="go">* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.</code>
<code class="go">| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.</code>
<code class="go">| * bd2f54a Put in fix for jam's NT handle leak.</code>
<code class="go">| * c0f29e7 Fix URL in a jam doc</code>
<code class="go">| * cc644ac Radstone's lynx port.</code>
<code class="go">[...]</code></pre>

<p>The first time you do this, it may take some time.
What’s happening is that Git Fusion is converting all the applicable changesets in the Perforce history into Git commits.
This happens locally on the server, so it’s relatively fast, but if you have a lot of history, it can still take some time.
Subsequent fetches do incremental conversion, so it’ll feel more like Git’s native speed.</p>

<p>As you can see, our repository looks exactly like any other Git repository you might work with.
There are three branches, and Git has helpfully created a local <code>master</code> branch that tracks <code>origin/master</code>.
Let’s do a bit of work, and create a couple of new commits:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">#</code> ...
<code class="gp">$</code> git log --oneline --decorate --graph --all
<code class="go">* cfd46ab (HEAD, master) Add documentation for new feature</code>
<code class="go">* a730d77 Whitespace</code>
<code class="go">* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.</code>
<code class="go">* bd2f54a Put in fix for jam's NT handle leak.</code>
<code class="go">[...]</code></pre>

<p>We have two new commits.
Now let’s check if anyone else has been working:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git fetch
<code class="go">remote: Counting objects: 5, done.</code>
<code class="go">remote: Compressing objects: 100% (3/3), done.</code>
<code class="go">remote: Total 3 (delta 2), reused 0 (delta 0)</code>
<code class="go">Unpacking objects: 100% (3/3), done.</code>
<code class="go">From https://10.0.1.254/Jam</code>
<code class="go">   d254865..6afeb15  master     -&gt; origin/master</code>
<code class="gp">$</code> git log --oneline --decorate --graph --all
<code class="go">* 6afeb15 (origin/master, origin/HEAD) Update copyright</code>
<code class="go">| * cfd46ab (HEAD, master) Add documentation for new feature</code>
<code class="go">| * a730d77 Whitespace</code>
<code class="go">|/</code>
<code class="go">* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.</code>
<code class="go">* bd2f54a Put in fix for jam's NT handle leak.</code>
<code class="go">[...]</code></pre>

<p>It looks like someone was!
You wouldn’t know it from this view, but the <code>6afeb15</code> commit was actually created using a Perforce client.
It just looks like another commit from Git’s point of view, which is exactly the point.
Let’s see how the Perforce server deals with a merge commit:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git merge origin/master
<code class="go">Auto-merging README</code>
<code class="go">Merge made by the 'recursive' strategy.</code>
<code class="go"> README | 2 +-</code>
<code class="go"> 1 file changed, 1 insertion(+), 1 deletion(-)</code>
<code class="gp">$</code> git push
<code class="go">Counting objects: 9, done.</code>
<code class="go">Delta compression using up to 8 threads.</code>
<code class="go">Compressing objects: 100% (9/9), done.</code>
<code class="go">Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.</code>
<code class="go">Total 9 (delta 6), reused 0 (delta 0)</code>
<code class="go">remote: Perforce: 100% (3/3) Loading commit tree into memory...</code>
<code class="go">remote: Perforce: 100% (5/5) Finding child commits...</code>
<code class="go">remote: Perforce: Running git fast-export...</code>
<code class="go">remote: Perforce: 100% (3/3) Checking commits...</code>
<code class="go">remote: Processing will continue even if connection is closed.</code>
<code class="go">remote: Perforce: 100% (3/3) Copying changelists...</code>
<code class="go">remote: Perforce: Submitting new Git commit objects to Perforce: 4</code>
<code class="go">To https://10.0.1.254/Jam</code>
<code class="go">   6afeb15..89cba2b  master -&gt; master</code></pre>

<p>Git thinks it worked.
Let’s take a look at the history of the <code>README</code> file from Perforce’s point of view, using the revision graph feature of <code>p4v</code>:</p>

<figure><div class="border-box"><img src="book/09-git-and-other-scms/images/git-fusion-perforce-graph.png" alt="Perforce revision graph resulting from Git push."/></div><figcaption>Perforce revision graph resulting from Git push.</figcaption></figure>

<p>If you’ve never seen this view before, it may seem confusing, but it shows the same concepts as a graphical viewer for Git history.
We’re looking at the history of the <code>README</code> file, so the directory tree at top left only shows that file as it surfaces in various branches.
At top right, we have a visual graph of how different revisions of the file are related, and the big-picture view of this graph is at bottom right.
The rest of the view is given to the details view for the selected revision (<code>2</code> in this case).</p>

<p>One thing to notice is that the graph looks exactly like the one in Git’s history.
Perforce didn’t have a named branch to store the <code>1</code> and <code>2</code> commits, so it made an “anonymous” branch in the <code>.git-fusion</code> directory to hold it.
This will also happen for named Git branches that don’t correspond to a named Perforce branch (and you can later map them to a Perforce branch using the configuration file).</p>

<p>Most of this happens behind the scenes, but the end result is that one person on a team can be using Git, another can be using Perforce, and neither of them will know about the other’s choice.</p>
</section>













<section data-type="sect4" data-pdf-bookmark="Git-Fusion Summary" id="idp29225776">
<h4>Git-Fusion Summary</h4>

<p>If you have (or can get) access to your Perforce server, Git Fusion is a great way to make Git and Perforce talk to each other.
There’s a bit of configuration involved, but the learning curve isn’t very steep.
This is one of the few sections in this chapter where cautions about using Git’s full power will not appear.
That’s not to say that Perforce will be happy with everything you throw at it – if you try to rewrite history that’s already been pushed, Git Fusion will reject it – but Git Fusion tries very hard to feel native.
You can even use Git submodules (though they’ll look strange to Perforce users), and merge branches (this will be recorded as an integration on the Perforce side).</p>

<p>If you can’t convince the administrator of your server to set up Git Fusion, there is still a way to use these tools together.</p>
</section>

</section>













<section data-type="sect3" data-pdf-bookmark="Git-p4" id="idp29418496">
<h3>Git-p4</h3>

<p><a data-type="indexterm" data-primary="git commands" data-secondary="p4" id="idp29442000"/>
Git-p4 is a two-way bridge between Git and Perforce.
It runs entirely inside your Git repository, so you won’t need any kind of access to the Perforce server (other than user credentials, of course).
Git-p4 isn’t as flexible or complete a solution as Git Fusion, but it does allow you to do most of what you’d want to do without being invasive to the server environment.</p>
<div data-type="note">
<p>You’ll need the <code>p4</code> tool somewhere in your <code>PATH</code> to work with git-p4.
As of this writing, it is freely available at <a href="http://www.perforce.com/downloads/Perforce/20-User"><em class="hyperlink">http://www.perforce.com/downloads/Perforce/20-User</em></a>.</p>
</div>












<section data-type="sect4" data-pdf-bookmark="Setting Up" id="idp29446752">
<h4>Setting Up</h4>

<p>For example purposes, we’ll be running the Perforce server from the Git Fusion OVA as shown above, but we’ll bypass the Git Fusion server and go directly to the Perforce version control.</p>

<p>In order to use the <code>p4</code> command-line client (which git-p4 depends on), you’ll need to set a couple of environment variables:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">export </code><code class="nv">P4PORT</code><code class="o">=</code>10.0.1.254:1666
<code class="gp">$</code> <code class="nb">export </code><code class="nv">P4USER</code><code class="o">=</code>john</pre>
</section>













<section data-type="sect4" data-pdf-bookmark="Getting Started" id="idp29454384">
<h4>Getting Started</h4>

<p>As with anything in Git, the first command is to clone:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git p4 clone //depot/www/live www-shallow
<code class="go">Importing from //depot/www/live into www-shallow</code>
<code class="go">Initialized empty Git repository in /private/tmp/www-shallow/.git/</code>
<code class="go">Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master</code></pre>

<p>This creates what in Git terms is a “shallow” clone; only the very latest Perforce revision is imported into Git; remember, Perforce isn’t designed to give every revision to every user.
This is enough to use Git as a Perforce client, but for other purposes it’s not enough.</p>

<p>Once it’s finished, we have a fully-functional Git repository:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">cd </code>myproject
<code class="gp">$</code> git log --oneline --all --graph --decorate
<code class="go">* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head</code></pre>

<p>Note how there’s a “p4” remote for the Perforce server, but everything else looks like a standard clone.
Actually, that’s a bit misleading; there isn’t actually a remote there.</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git remote -v</pre>

<p>No remotes exist in this repository at all.
Git-p4 has created some refs to represent the state of the server, and they look like remote refs to <code>git log</code>, but they’re not managed by Git itself, and you can’t push to them.</p>
</section>













<section data-type="sect4" data-pdf-bookmark="Workflow" id="idp29336464">
<h4>Workflow</h4>

<p>Okay, let’s do some work.
Let’s assume you’ve made some progress on a very important feature, and you’re ready to show it to the rest of your team.</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log --oneline --all --graph --decorate
<code class="go">* 018467c (HEAD, master) Change page title</code>
<code class="go">* c0fb617 Update link</code>
<code class="go">* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head</code></pre>

<p>We’ve made two new commits that we’re ready to submit to the Perforce server.
Let’s check if anyone else was working today:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git p4 sync
<code class="go">git p4 sync</code>
<code class="go">Performing incremental import into refs/remotes/p4/master git branch</code>
<code class="go">Depot paths: //depot/www/live/</code>
<code class="go">Import destination: refs/remotes/p4/master</code>
<code class="go">Importing revision 12142 (100%)</code>
<code class="gp">$</code> git log --oneline --all --graph --decorate
<code class="go">* 75cd059 (p4/master, p4/HEAD) Update copyright</code>
<code class="go">| * 018467c (HEAD, master) Change page title</code>
<code class="go">| * c0fb617 Update link</code>
<code class="go">|/</code>
<code class="go">* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>

<p>Looks like they were, and <code>master</code> and <code>p4/master</code> have diverged.
Perforce’s branching system is <em>nothing</em> like Git’s, so submitting merge commits doesn’t make any sense.
Git-p4 recommends that you rebase your commits, and even comes with a shortcut to do so:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git p4 rebase
<code class="go">Performing incremental import into refs/remotes/p4/master git branch</code>
<code class="go">Depot paths: //depot/www/live/</code>
<code class="go">No changes to import!</code>
<code class="go">Rebasing the current branch onto remotes/p4/master</code>
<code class="go">First, rewinding head to replay your work on top of it...</code>
<code class="go">Applying: Update link</code>
<code class="go">Applying: Change page title</code>
<code class="go"> index.html | 2 +-</code>
<code class="go"> 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>

<p>You can probably tell from the output, but <code>git p4 rebase</code> is a shortcut for <code>git p4 sync</code> followed by <code>git rebase p4/master</code>.
It’s a bit smarter than that, especially when working with multiple branches, but this is a good approximation.</p>

<p>Now our history is linear again, and we’re ready to contribute our changes back to Perforce.
The <code>git p4 submit</code> command will try to create a new Perforce revision for every Git commit between <code>p4/master</code> and <code>master</code>.
Running it drops us into our favorite editor, and the contents of the file look something like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">#</code> A Perforce Change Specification.
<code class="gp">#</code>
<code class="gp">#</code>  Change:      The change number. <code class="s1">'new'</code> on a new changelist.
<code class="gp">#</code>  Date:        The date this specification was last modified.
<code class="gp">#</code>  Client:      The client on which the changelist was created.  Read-only.
<code class="gp">#</code>  User:        The user who created the changelist.
<code class="gp">#</code>  Status:      Either <code class="s1">'pending'</code> or <code class="s1">'submitted'</code>. Read-only.
<code class="gp">#</code>  Type:        Either <code class="s1">'public'</code> or <code class="s1">'restricted'</code>. Default is <code class="s1">'public'</code>.
<code class="gp">#</code>  Description: Comments about the changelist.  Required.
<code class="gp">#</code>  Jobs:        What opened <code class="nb">jobs </code>are to be closed by this changelist.
<code class="gp">#</code>               You may delete <code class="nb">jobs </code>from this list.  <code class="o">(</code>New changelists only.<code class="o">)</code>
<code class="gp">#</code>  Files:       What opened files from the default changelist are to be added
<code class="gp">#</code>               to this changelist.  You may delete files from this list.
<code class="gp">#</code>               <code class="o">(</code>New changelists only.<code class="o">)</code>

<code class="go">Change:  new</code>

<code class="go">Client:  john_bens-mbp_8487</code>

<code class="go">User: john</code>

<code class="go">Status:  new</code>

<code class="go">Description:</code>
<code class="go">   Update link</code>

<code class="go">Files:</code>
<code class="go">   //depot/www/live/index.html   # edit</code>


<code class="gp">#</code><code class="c">####### git author ben@straub.cc does not match your p4 account.</code>
<code class="gp">#</code><code class="c">####### Use option --preserve-user to modify authorship.</code>
<code class="gp">#</code><code class="c">####### Variable git-p4.skipUserNameCheck hides this message.</code>
<code class="gp">#</code><code class="c">####### everything below this line is just the diff #######</code>
<code class="go">--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000</code>
<code class="go">+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000</code>
<code class="go">@@ -60,7 +60,7 @@</code>
<code class="go"> &lt;/td&gt;</code>
<code class="go"> &lt;td valign=top&gt;</code>
<code class="go"> Source and documentation for</code>
<code class="go">-&lt;a href="http://www.perforce.com/jam/jam.html"&gt;</code>
<code class="go">+&lt;a href="jam.html"&gt;</code>
<code class="go"> Jam/MR&lt;/a&gt;,</code>
<code class="go"> a software build tool.</code>
<code class="go"> &lt;/td&gt;</code></pre>

<p>This is mostly the same content you’d see by running <code>p4 submit</code>, except the stuff at the end which git-p4 has helpfully included.
Git-p4 tries to honor your Git and Perforce settings individually when it has to provide a name for a commit or changeset, but in some cases you want to override it.
For example, if the Git commit you’re importing was written by a contributor who doesn’t have a Perforce user account, you may still want the resulting changeset to look like they write it (and not you).</p>

<p>Git-p4 has helpfully imported the message from the Git commit as the content for this Perforce changeset, so all we have to do is save and quit, twice (once for each commit).
The resulting shell output will look something like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git p4 submit
<code class="go">Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/</code>
<code class="go">Synchronizing p4 checkout...</code>
<code class="go">... - file(s) up-to-date.</code>
<code class="go">Applying dbac45b Update link</code>
<code class="go">//depot/www/live/index.html#4 - opened for edit</code>
<code class="go">Change 12143 created with 1 open file(s).</code>
<code class="go">Submitting change 12143.</code>
<code class="go">Locking 1 files ...</code>
<code class="go">edit //depot/www/live/index.html#5</code>
<code class="go">Change 12143 submitted.</code>
<code class="go">Applying 905ec6a Change page title</code>
<code class="go">//depot/www/live/index.html#5 - opened for edit</code>
<code class="go">Change 12144 created with 1 open file(s).</code>
<code class="go">Submitting change 12144.</code>
<code class="go">Locking 1 files ...</code>
<code class="go">edit //depot/www/live/index.html#6</code>
<code class="go">Change 12144 submitted.</code>
<code class="go">All commits applied!</code>
<code class="go">Performing incremental import into refs/remotes/p4/master git branch</code>
<code class="go">Depot paths: //depot/www/live/</code>
<code class="go">Import destination: refs/remotes/p4/master</code>
<code class="go">Importing revision 12144 (100%)</code>
<code class="go">Rebasing the current branch onto remotes/p4/master</code>
<code class="go">First, rewinding head to replay your work on top of it...</code>
<code class="gp">$</code> git log --oneline --all --graph --decorate
<code class="go">* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title</code>
<code class="go">* 05f1ade Update link</code>
<code class="go">* 75cd059 Update copyright</code>
<code class="go">* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>

<p>The result is as though we just did a <code>git push</code>, which is the closest analogy to what actually did happen.</p>

<p>Note that during this process every Git commit is turned into a Perforce changeset; if you want to squash them down into a single changeset, you can do that with an interactive rebase before running <code>git p4 submit</code>.
Also note that the SHA-1 hashes of all the commits that were submitted as changesets have changed; this is because git-p4 adds a line to the end of each commit it converts:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log -1
<code class="go">commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145</code>
<code class="go">Author: John Doe &lt;john@example.com&gt;</code>
<code class="go">Date:   Sun Aug 31 10:31:44 2014 -0800</code>

<code class="go">    Change page title</code>

<code class="go">    [git-p4: depot-paths = "//depot/www/live/": change = 12144]</code></pre>

<p>What happens if you try to submit a merge commit?
Let’s give it a try.
Here’s the situation we’ve gotten ourselves into:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log --oneline --all --graph --decorate
<code class="go">* 3be6fd8 (HEAD, master) Correct email address</code>
<code class="go">*   1dcbf21 Merge remote-tracking branch 'p4/master'</code>
<code class="go">|\</code>
<code class="go">| * c4689fc (p4/master, p4/HEAD) Grammar fix</code>
<code class="go">* | cbacd0a Table borders: yes please</code>
<code class="go">* | b4959b6 Trademark</code>
<code class="go">|/</code>
<code class="go">* 775a46f Change page title</code>
<code class="go">* 05f1ade Update link</code>
<code class="go">* 75cd059 Update copyright</code>
<code class="go">* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>

<p>The Git and Perforce history diverge after 775a46f.
The Git side has two commits, then a merge commit with the Perforce head, then another commit.
We’re going to try to submit these on top of a single changeset on the Perforce side.
Let’s see what would happen if we tried to submit now:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git p4 submit -n
<code class="go">Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/</code>
<code class="go">Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/</code>
<code class="go">Would apply</code>
<code class="go">  b4959b6 Trademark</code>
<code class="go">  cbacd0a Table borders: yes please</code>
<code class="go">  3be6fd8 Correct email address</code></pre>

<p>The <code>-n</code> flag is short for <code>--dry-run</code>, which tries to report what would happen if the submit command were run for real.
In this case, it looks like we’d be creating three Perforce changesets, which correspond to the three non-merge commits that don’t yet exist on the Perforce server.
That sounds like exactly what we want, let’s see how it turns out:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git p4 submit
<code class="go">[…]</code>
<code class="gp">$</code> git log --oneline --all --graph --decorate
<code class="go">* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address</code>
<code class="go">* 1b79a80 Table borders: yes please</code>
<code class="go">* 0097235 Trademark</code>
<code class="go">* c4689fc Grammar fix</code>
<code class="go">* 775a46f Change page title</code>
<code class="go">* 05f1ade Update link</code>
<code class="go">* 75cd059 Update copyright</code>
<code class="go">* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>

<p>Our history became linear, just as though we had rebased before submitting (which is in fact exactly what happened).
This means you can be free to create, work on, throw away, and merge branches on the Git side without fear that your history will somehow become incompatible with Perforce.
If you can rebase it, you can contribute it to a Perforce server.</p>
</section>













<section data-type="sect4" data-pdf-bookmark="Branching" id="_git_p4_branches">
<h4>Branching</h4>

<p>If your Perforce project has multiple branches, you’re not out of luck; git-p4 can handle that in a way that makes it feel like Git.
Let’s say your Perforce depot is laid out like this:</p>

<pre data-type="programlisting">//depot
  └── project
      ├── main
      └── dev</pre>

<p>And let’s say you have a <code>dev</code> branch, which has a view spec that looks like this:</p>

<pre data-type="programlisting">//depot/project/main/... //depot/project/dev/...</pre>

<p>Git-p4 can automatically detect that situation and do the right thing:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git p4 clone --detect-branches //depot/project@all
<code class="go">Importing from //depot/project@all into project</code>
<code class="go">Initialized empty Git repository in /private/tmp/project/.git/</code>
<code class="go">Importing revision 20 (50%)</code>
<code class="go">    Importing new branch project/dev</code>

<code class="go">    Resuming with change 20</code>
<code class="go">Importing revision 22 (100%)</code>
<code class="go">Updated branches: main dev</code>
<code class="gp">$</code> <code class="nb">cd </code>project<code class="p">;</code> git log --oneline --all --graph --decorate
<code class="go">* eae77ae (HEAD, p4/master, p4/HEAD, master) main</code>
<code class="go">| * 10d55fb (p4/project/dev) dev</code>
<code class="go">| * a43cfae Populate //depot/project/main/... //depot/project/dev/....</code>
<code class="go">|/</code>
<code class="go">* 2b83451 Project init</code></pre>

<p>Note the “@all” specifier in the depot path; that tells git-p4 to clone not just the latest changeset for that subtree, but all changesets that have ever touched those paths.
This is closer to Git’s concept of a clone, but if you’re working on a project with a long history, it could take a while.</p>

<p>The <code>--detect-branches</code> flag tells git-p4 to use Perforce’s branch specs to map the branches to Git refs.
If these mappings aren’t present on the Perforce server (which is a perfectly valid way to use Perforce), you can tell git-p4 what the branch mappings are, and you get the same result:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git init project
<code class="go">Initialized empty Git repository in /tmp/project/.git/</code>
<code class="gp">$</code> <code class="nb">cd </code>project
<code class="gp">$</code> git config git-p4.branchList main:dev
<code class="gp">$</code> git clone --detect-branches //depot/project@all .</pre>

<p>Setting the <code>git-p4.branchList</code> configuration variable to <code>main:dev</code> tells git-p4 that “main” and “dev” are both branches, and the second one is a child of the first one.</p>

<p>If we now <code>git checkout -b dev p4/project/dev</code> and make some commits, git-p4 is smart enough to target the right branch when we do <code>git p4 submit</code>.
Unfortunately, git-p4 can’t mix shallow clones and multiple branches; if you have a huge project and want to work on more than one branch, you’ll have to <code>git p4 clone</code> once for each branch you want to submit to.</p>

<p>For creating or integrating branches, you’ll have to use a Perforce client.
Git-p4 can only sync and submit to existing branches, and it can only do it one linear changeset at a time.
If you merge two branches in Git and try to submit the new changeset, all that will be recorded is a bunch of file changes; the metadata about which branches are involved in the integration will be lost.</p>
</section>

</section>













<section data-type="sect3" data-pdf-bookmark="Git and Perforce Summary" id="idp29418832">
<h3>Git and Perforce Summary</h3>

<p>Git-p4 makes it possible to use a Git workflow with a Perforce server, and it’s pretty good at it.
However, it’s important to remember that Perforce is in charge of the source, and you’re only using Git to work locally.
Just be really careful about sharing Git commits; if you have a remote that other people use, don’t push any commits that haven’t already been submitted to the Perforce server.</p>

<p>If you want to freely mix the use of Perforce and Git as clients for source control, and you can convince the server administrator to install it, Git Fusion makes using Git a first-class version-control client for a Perforce server.</p>
</section>



</section>













<section data-type="sect2" data-pdf-bookmark="Git and TFS" id="idp29770304">
<h2>Git and TFS</h2>

<p><a data-type="indexterm" data-primary="Interoperation with other VCSs" data-secondary="TFS" id="idp30052784"/>
<a data-type="indexterm" data-primary="TFS" id="idp30053856"/><a data-type="indexterm" data-primary="TFVC" data-see="TFS" id="idp30054560"/>
Git is becoming popular with Windows developers, and if you’re writing code on Windows, there’s a good chance you’re using Microsoft’s Team Foundation Server (TFS).
TFS is a collaboration suite that includes defect and work-item tracking, process support for Scrum and others, code review, and version control.
There’s a bit of confusion ahead: <strong>TFS</strong> is the server, which supports controlling source code using both Git and their own custom VCS, which they’ve dubbed <strong>TFVC</strong> (Team Foundation Version Control).
Git support is a somewhat new feature for TFS (shipping with the 2013 version), so all of the tools that predate that refer to the version-control portion as “TFS”, even though they’re mostly working with TFVC.</p>

<p>If you find yourself on a team that’s using TFVC but you’d rather use Git as your version-control client, there’s a project for you.</p>










<section data-type="sect3" data-pdf-bookmark="Which Tool" id="idp30057904">
<h3>Which Tool</h3>

<p><a data-type="indexterm" data-primary="git-tf" id="idp30059344"/><a data-type="indexterm" data-primary="git-tfs" id="idp30060048"/>
In fact, there are two: git-tf and git-tfs.</p>

<p>Git-tfs (found at <a href="https://github.com/git-tfs/git-tfs"><em class="hyperlink">https://github.com/git-tfs/git-tfs</em></a>) is a .NET project, and (as of this writing) it only runs on Windows.
To work with Git repositories, it uses the .NET bindings for libgit2, a library-oriented implementation of Git which is highly performant and allows a lot of flexibility with the guts of a Git repository.
Libgit2 is not a complete implementation of Git, so to cover the difference git-tfs will actually call the command-line Git client for some operations, so there are no artificial limits on what it can do with Git repositories.
Its support of TFVC features is very mature, since it uses the Visual Studio assemblies for operations with servers.
This does mean you’ll need access to those assemblies, which means you need to install a recent version of Visual Studio (any edition since version 2010, including Express since version 2012), or the Visual Studio SDK.</p>

<p>Git-tf (whose home is at <a href="https://gittf.codeplex.com"><em class="hyperlink">https://gittf.codeplex.com</em></a>) is a Java project, and as such runs on any computer with a Java runtime environment.
It interfaces with Git repositories through JGit (a JVM implementation of Git), which means it has virtually no limitations in terms of Git functions.
However, its support for TFVC is limited as compared to git-tfs – it does not support branches, for instance.</p>

<p>So each tool has pros and cons, and there are plenty of situations that favor one over the other.
We’ll cover the basic usage of both of them in this book.</p>
<div data-type="note">
<p>You’ll need access to a TFVC-based repository to follow along with these instructions.
These aren’t as plentiful in the wild as Git or Subversion repositories, so you may need to create one of your own.
Codeplex (<a href="https://www.codeplex.com"><em class="hyperlink">https://www.codeplex.com</em></a>) or Visual Studio Online (<a href="http://www.visualstudio.com"><em class="hyperlink">http://www.visualstudio.com</em></a>) are both good choices for this.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Getting Started: git-tf" id="idp29921600">
<h3>Getting Started: <code>git-tf</code></h3>

<p>The first thing you do, just as with any Git project, is clone.
Here’s what that looks like with <code>git-tf</code>:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git tf clone https://tfs.codeplex.com:443/tfs/TFS13 <code class="nv">$/</code>myproject/Main project_git</pre>

<p>The first argument is the URL of a TFVC collection, the second is of the form <code>$/project/branch</code>, and the third is the path to the local Git repository that is to be created (this last one is optional).
Git-tf can only work with one branch at a time; if you want to make checkins on a different TFVC branch, you’ll have to make a new clone from that branch.</p>

<p>This creates a fully functional Git repository:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">cd </code>project_git
<code class="gp">$</code> git log --all --oneline --decorate
<code class="go">512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message</code></pre>

<p>This is called a <em>shallow</em> clone, meaning that only the latest changeset has been downloaded.
TFVC isn’t designed for each client to have a full copy of the history, so git-tf defaults to only getting the latest version, which is much faster.</p>

<p>If you have some time, it’s probably worth it to clone the entire project history, using the <code>--deep</code> option:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git tf clone https://tfs.codeplex.com:443/tfs/TFS13 <code class="nv">$/</code>myproject/Main <code class="se">\</code>
<code class="go">  project_git --deep</code>
<code class="go">Username: domain\user</code>
<code class="go">Password:</code>
<code class="go">Connecting to TFS...</code>
<code class="go">Cloning $/myproject into /tmp/project_git: 100%, done.</code>
<code class="go">Cloned 4 changesets. Cloned last changeset 35190 as d44b17a</code>
<code class="gp">$</code> <code class="nb">cd </code>project_git
<code class="gp">$</code> git log --all --oneline --decorate
<code class="go">d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye</code>
<code class="go">126aa7b (tag: TFS_C35189)</code>
<code class="go">8f77431 (tag: TFS_C35178) FIRST</code>
<code class="go">0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \</code>
<code class="go">        Team Project Creation Wizard</code></pre>

<p>Notice the tags with names like <code>TFS_C35189</code>; this is a feature that helps you know which Git commits are associated with TFVC changesets.
This is a nice way to represent it, since you can see with a simple log command which of your commits is associated with a snapshot that also exists in TFVC.
They aren’t necessary (and in fact you can turn them off with <code>git config git-tf.tag false</code>) – git-tf keeps the real commit-changeset mappings in the <code>.git/git-tf</code> file.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Getting Started: git-tfs" id="idp29922192">
<h3>Getting Started: <code>git-tfs</code></h3>

<p>Git-tfs cloning behaves a bit differently.
Observe:</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">tfs</code> <code class="n">clone</code> <code class="p">-</code><code class="n">-with-branches</code> <code class="p">\</code>
    <code class="n">https</code><code class="err">:</code><code class="p">//</code><code class="n">username</code><code class="p">.</code><code class="n">visualstudio</code><code class="p">.</code><code class="n">com</code><code class="p">/</code><code class="n">DefaultCollection</code> <code class="p">\</code>
    <code class="p">$/</code><code class="n">project</code><code class="p">/</code><code class="n">Trunk</code> <code class="n">project_git</code>
<code class="n">Initialized</code> <code class="n">empty</code> <code class="n">Git</code> <code class="n">repository</code> <code class="k">in</code> <code class="n">C</code><code class="err">:</code><code class="p">/</code><code class="n">Users</code><code class="p">/</code><code class="n">ben</code><code class="p">/</code><code class="n">project_git</code><code class="p">/.</code><code class="n">git</code><code class="p">/</code>
<code class="n">C15</code> <code class="p">=</code> <code class="n">b75da1aba1ffb359d00e85c52acb261e4586b0c9</code>
<code class="n">C16</code> <code class="p">=</code> <code class="n">c403405f4989d73a2c3c119e79021cb2104ce44a</code>
<code class="n">Tfs</code> <code class="n">branches</code> <code class="n">found</code><code class="err">:</code>
<code class="p">-</code> <code class="p">$/</code><code class="n">tfvc-test</code><code class="p">/</code><code class="n">featureA</code>
<code class="n">The</code> <code class="n">name</code> <code class="n">of</code> <code class="n">the</code> <code class="n">local</code> <code class="n">branch</code> <code class="n">will</code> <code class="n">be</code> <code class="err">:</code> <code class="n">featureA</code>
<code class="n">C17</code> <code class="p">=</code> <code class="n">d202b53f67bde32171d5078968c644e562f1c439</code>
<code class="n">C18</code> <code class="p">=</code> <code class="n">44cd729d8df868a8be20438fdeeefb961958b674</code></pre>

<p>Notice the <code>--with-branches</code> flag.
Git-tfs is capable of mapping TFVC branches to Git branches, and this flag tells it to set up a local Git branch for every TFVC branch.
This is highly recommended if you’ve ever branched or merged in TFS, but it won’t work with a server older than TFS 2010 – before that release, “branches” were just folders, so git-tfs can’t tell them from regular folders.</p>

<p>Let’s take a look at the resulting Git repository:</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">log</code> <code class="p">-</code><code class="n">-oneline</code> <code class="p">-</code><code class="n">-graph</code> <code class="p">-</code><code class="n">-decorate</code> <code class="p">-</code><code class="n">-all</code>
<code class="p">*</code> <code class="n">44cd729</code> <code class="p">(</code><code class="n">tfs</code><code class="p">/</code><code class="n">featureA</code><code class="p">,</code> <code class="n">featureA</code><code class="p">)</code> <code class="n">Goodbye</code>
<code class="p">*</code> <code class="n">d202b53</code> <code class="n">Branched</code> <code class="n">from</code> <code class="p">$/</code><code class="n">tfvc-test</code><code class="p">/</code><code class="n">Trunk</code>
<code class="p">*</code> <code class="n">c403405</code> <code class="p">(</code><code class="n">HEAD</code><code class="p">,</code> <code class="n">tfs</code><code class="p">/</code><code class="k">default</code><code class="p">,</code> <code class="n">master</code><code class="p">)</code> <code class="n">Hello</code>
<code class="p">*</code> <code class="n">b75da1a</code> <code class="n">New</code> <code class="n">project</code>
<code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">log</code> <code class="p">-</code><code class="n">1</code>
<code class="n">commit</code> <code class="n">c403405f4989d73a2c3c119e79021cb2104ce44a</code>
<code class="n">Author</code><code class="err">:</code> <code class="n">Ben</code> <code class="n">Straub</code> <code class="p">&lt;</code><code class="n">ben</code><code class="nv">@straub</code><code class="p">.</code><code class="n">cc</code><code class="p">&gt;</code>
<code class="n">Date</code><code class="err">:</code>   <code class="n">Fri</code> <code class="n">Aug</code> <code class="n">1</code> <code class="n">03</code><code class="err">:</code><code class="n">41</code><code class="err">:</code><code class="n">59</code> <code class="n">2014</code> <code class="p">+</code><code class="n">0000</code>

    <code class="n">Hello</code>

    <code class="n">git-tfs-id</code><code class="err">:</code> <code class="p">[</code><code class="n">https</code><code class="err">:</code><code class="p">//</code><code class="n">username</code><code class="p">.</code><code class="n">visualstudio</code><code class="p">.</code><code class="n">com</code><code class="p">/</code><code class="n">DefaultCollection</code><code class="p">]$/</code><code class="n">myproject</code><code class="p">/</code><code class="n">Trunk</code><code class="p">;</code><code class="n">C16</code></pre>

<p>There are two local branches, <code>master</code> and <code>featureA</code>, which represent the initial starting point of the clone (<code>Trunk</code> in TFVC) and a child branch (<code>featureA</code> in TFVC).
You can also see that the <code>tfs</code> “remote” has a couple of refs too: <code>default</code> and <code>featureA</code>, which represent TFVC branches.
Git-tfs maps the branch you cloned from to <code>tfs/default</code>, and others get their own names.</p>

<p>Another thing to notice is the <code>git-tfs-id:</code> lines in the commit messages.
Instead of tags, git-tfs uses these markers to relate TFVC changesets to Git commits.
This has the implication that your Git commits will have a different SHA-1 hash before and after they have been pushed to TFVC.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Git-tf[s] Workflow" id="idp30303936">
<h3>Git-tf[s] Workflow</h3>
<div data-type="note">
<p>Regardless of which tool you’re using, you should set a couple of Git configuration values to avoid running into issues.</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git config <code class="nb">set</code> --local core.ignorecase<code class="o">=</code><code class="nb">true</code>
<code class="gp">$</code><code class="nb"> </code>git config <code class="nb">set</code> --local core.autocrlf<code class="o">=</code><code class="nb">false</code></pre>
</div>

<p>The obvious next thing you’re going to want to do is work on the project.
TFVC and TFS have several features that may add complexity to your workflow:</p>
<ol>
<li>
<p>Feature branches that aren’t represented in TFVC add a bit of complexity.
This has to do with the <strong>very</strong> different ways that TFVC and Git represent branches.</p>
</li>
<li>
<p>Be aware that TFVC allows users to “checkout” files from the server, locking them so nobody else can edit them.
This obviously won’t stop you from editing them in your local repository, but it could get in the way when it comes time to push your changes up to the TFVC server.</p>
</li>
<li>
<p>TFS has the concept of “gated” checkins, where a TFS build-test cycle has to complete successfully before the checkin is allowed.
This uses the “shelve” function in TFVC, which we don’t cover in detail here.
  You can fake this in a manual fashion with git-tf, and git-tfs provides the <code>checkintool</code> command which is gate-aware.</p>
</li>

</ol>

<p>In the interest of brevity, what we’ll cover here is the happy path, which sidesteps or avoids most of these issues.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Workflow: git-tf" id="idp30311072">
<h3>Workflow: <code>git-tf</code></h3>

<p>Let’s say you’ve done some work, made a couple of Git commits on <code>master</code>, and you’re ready to share your progress on the TFVC server.
Here’s our Git repository:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log --oneline --graph --decorate --all
<code class="go">* 4178a82 (HEAD, master) update code</code>
<code class="go">* 9df2ae3 update readme</code>
<code class="go">* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye</code>
<code class="go">* 126aa7b (tag: TFS_C35189)</code>
<code class="go">* 8f77431 (tag: TFS_C35178) FIRST</code>
<code class="go">* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \</code>
<code class="go">          Team Project Creation Wizard</code></pre>

<p>We want to take the snapshot that’s in the <code>4178a82</code> commit and push it up to the TFVC server.
First things first: let’s see if any of our teammates did anything since we last connected:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git tf fetch
<code class="go">Username: domain\user</code>
<code class="go">Password:</code>
<code class="go">Connecting to TFS...</code>
<code class="go">Fetching $/myproject at latest changeset: 100%, done.</code>
<code class="go">Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.</code>
<code class="gp">$</code> git log --oneline --graph --decorate --all
<code class="go">* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text</code>
<code class="go">| * 4178a82 (HEAD, master) update code</code>
<code class="go">| * 9df2ae3 update readme</code>
<code class="go">|/</code>
<code class="go">* d44b17a (tag: TFS_C35190) Goodbye</code>
<code class="go">* 126aa7b (tag: TFS_C35189)</code>
<code class="go">* 8f77431 (tag: TFS_C35178) FIRST</code>
<code class="go">* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \</code>
<code class="go">          Team Project Creation Wizard</code></pre>

<p>Looks like someone else is working, too, and now we have divergent history.
This is where Git shines, but we have two choices of how to proceed:</p>
<ol>
<li>
<p>Making a merge commit feels natural as a Git user (after all, that’s what <code>git pull</code> does), and git-tf can do this for you with a simple <code>git tf pull</code>.
Be aware, however, that TFVC doesn’t think this way, and if you push merge commits your history will start to look different on both sides, which can be confusing.
However, if you plan on submitting all of your changes as one changeset, this is probably the easiest choice.</p>
</li>
<li>
<p>Rebasing makes our commit history linear, which means we have the option of converting each of our Git commits into a TFVC changeset.
Since this leaves the most options open, we recommend you do it this way; git-tf even makes it easy for you with <code>git tf pull --rebase</code>.</p>
</li>

</ol>

<p>The choice is yours.
For this example, we’ll be rebasing:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git rebase FETCH_HEAD
<code class="go">First, rewinding head to replay your work on top of it...</code>
<code class="go">Applying: update readme</code>
<code class="go">Applying: update code</code>
<code class="gp">$</code> git log --oneline --graph --decorate --all
<code class="go">* 5a0e25e (HEAD, master) update code</code>
<code class="go">* 6eb3eb5 update readme</code>
<code class="go">* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text</code>
<code class="go">* d44b17a (tag: TFS_C35190) Goodbye</code>
<code class="go">* 126aa7b (tag: TFS_C35189)</code>
<code class="go">* 8f77431 (tag: TFS_C35178) FIRST</code>
<code class="go">* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \</code>
<code class="go">          Team Project Creation Wizard</code></pre>

<p>Now we’re ready to make a checkin to the TFVC server.
Git-tf gives you the choice of making a single changeset that represents all the changes since the last one (<code>--shallow</code>, which is the default) and creating a new changeset for each Git commit (<code>--deep</code>).
For this example, we’ll just create one changeset:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git tf checkin -m <code class="s1">'Updating readme and code'</code>
<code class="go">Username: domain\user</code>
<code class="go">Password:</code>
<code class="go">Connecting to TFS...</code>
<code class="go">Checking in to $/myproject: 100%, done.</code>
<code class="go">Checked commit 5a0e25e in as changeset 35348</code>
<code class="gp">$</code> git log --oneline --graph --decorate --all
<code class="go">* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code</code>
<code class="go">* 6eb3eb5 update readme</code>
<code class="go">* 8ef06a8 (tag: TFS_C35320) just some text</code>
<code class="go">* d44b17a (tag: TFS_C35190) Goodbye</code>
<code class="go">* 126aa7b (tag: TFS_C35189)</code>
<code class="go">* 8f77431 (tag: TFS_C35178) FIRST</code>
<code class="go">* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \</code>
<code class="go">          Team Project Creation Wizard</code></pre>

<p>There’s a new <code>TFS_C35348</code> tag, indicating that TFVC is storing the exact same snapshot as the <code>5a0e25e</code> commit.
It’s important to note that not every Git commit needs to have an exact counterpart in TFVC; the <code>6eb3eb5</code> commit, for example, doesn’t exist anywhere on the server.</p>

<p>That’s the main workflow.
There are a couple of other considerations you’ll want to keep in mind:</p>

<ul>
<li>
<p>There is no branching.
Git-tf can only create Git repositories from one TFVC branch at a time.</p>
</li>
<li>
<p>Collaborate using either TFVC or Git, but not both.
Different git-tf clones of the same TFVC repository may have different commit SHA-1 hashes, which will cause no end of headaches.</p>
</li>
<li>
<p>If your team’s workflow includes collaborating in Git and syncing periodically with TFVC, only connect to TFVC with one of the Git repositories.</p>
</li>
</ul>
</section>













<section data-type="sect3" data-pdf-bookmark="Workflow: git-tfs" id="idp27461136">
<h3>Workflow: <code>git-tfs</code></h3>

<p>Let’s walk through the same scenario using git-tfs.
Here are the new commits we’ve made to the <code>master</code> branch in our Git repository:</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">log</code> <code class="p">-</code><code class="n">-oneline</code> <code class="p">-</code><code class="n">-graph</code> <code class="p">-</code><code class="n">-all</code> <code class="p">-</code><code class="n">-decorate</code>
<code class="p">*</code> <code class="n">c3bd3ae</code> <code class="p">(</code><code class="n">HEAD</code><code class="p">,</code> <code class="n">master</code><code class="p">)</code> <code class="n">update</code> <code class="n">code</code>
<code class="p">*</code> <code class="n">d85e5a2</code> <code class="n">update</code> <code class="n">readme</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">44cd729</code> <code class="p">(</code><code class="n">tfs</code><code class="p">/</code><code class="n">featureA</code><code class="p">,</code> <code class="n">featureA</code><code class="p">)</code> <code class="n">Goodbye</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">d202b53</code> <code class="n">Branched</code> <code class="n">from</code> <code class="p">$/</code><code class="n">tfvc-test</code><code class="p">/</code><code class="n">Trunk</code>
<code class="p">|/</code>
<code class="p">*</code> <code class="n">c403405</code> <code class="p">(</code><code class="n">tfs</code><code class="p">/</code><code class="k">default</code><code class="p">)</code> <code class="n">Hello</code>
<code class="p">*</code> <code class="n">b75da1a</code> <code class="n">New</code> <code class="n">project</code></pre>

<p>Now let’s see if anyone else has done work while we were hacking away:</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">tfs</code> <code class="n">fetch</code>
<code class="n">C19</code> <code class="p">=</code> <code class="n">aea74a0313de0a391940c999e51c5c15c381d91d</code>
<code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">log</code> <code class="p">-</code><code class="n">-all</code> <code class="p">-</code><code class="n">-oneline</code> <code class="p">-</code><code class="n">-graph</code> <code class="p">-</code><code class="n">-decorate</code>
<code class="p">*</code> <code class="n">aea74a0</code> <code class="p">(</code><code class="n">tfs</code><code class="p">/</code><code class="k">default</code><code class="p">)</code> <code class="n">update</code> <code class="n">documentation</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">c3bd3ae</code> <code class="p">(</code><code class="n">HEAD</code><code class="p">,</code> <code class="n">master</code><code class="p">)</code> <code class="n">update</code> <code class="n">code</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">d85e5a2</code> <code class="n">update</code> <code class="n">readme</code>
<code class="p">|/</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">44cd729</code> <code class="p">(</code><code class="n">tfs</code><code class="p">/</code><code class="n">featureA</code><code class="p">,</code> <code class="n">featureA</code><code class="p">)</code> <code class="n">Goodbye</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">d202b53</code> <code class="n">Branched</code> <code class="n">from</code> <code class="p">$/</code><code class="n">tfvc-test</code><code class="p">/</code><code class="n">Trunk</code>
<code class="p">|/</code>
<code class="p">*</code> <code class="n">c403405</code> <code class="n">Hello</code>
<code class="p">*</code> <code class="n">b75da1a</code> <code class="n">New</code> <code class="n">project</code></pre>

<p>Yes, it turns out our coworker has added a new TFVC changeset, which shows up as the new <code>aea74a0</code> commit, and the <code>tfs/default</code> remote branch has moved.</p>

<p>As with git-tf, we have two fundamental options for how to resolve this divergent history:</p>
<ol>
<li>
<p>Rebase to preserve a linear history.</p>
</li>
<li>
<p>Merge to preserve what actually happened.</p>
</li>

</ol>

<p>In this case, we’re going to do a “deep” checkin, where every Git commit becomes a TFVC changeset, so we want to rebase.</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">rebase</code> <code class="n">tfs</code><code class="p">/</code><code class="k">default</code>
<code class="n">First</code><code class="p">,</code> <code class="n">rewinding</code> <code class="n">head</code> <code class="n">to</code> <code class="n">replay</code> <code class="n">your</code> <code class="n">work</code> <code class="n">on</code> <code class="n">top</code> <code class="n">of</code> <code class="n">it</code><code class="p">...</code>
<code class="n">Applying</code><code class="err">:</code> <code class="n">update</code> <code class="n">readme</code>
<code class="n">Applying</code><code class="err">:</code> <code class="n">update</code> <code class="n">code</code>
<code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">log</code> <code class="p">-</code><code class="n">-all</code> <code class="p">-</code><code class="n">-oneline</code> <code class="p">-</code><code class="n">-graph</code> <code class="p">-</code><code class="n">-decorate</code>
<code class="p">*</code> <code class="n">10a75ac</code> <code class="p">(</code><code class="n">HEAD</code><code class="p">,</code> <code class="n">master</code><code class="p">)</code> <code class="n">update</code> <code class="n">code</code>
<code class="p">*</code> <code class="n">5cec4ab</code> <code class="n">update</code> <code class="n">readme</code>
<code class="p">*</code> <code class="n">aea74a0</code> <code class="p">(</code><code class="n">tfs</code><code class="p">/</code><code class="k">default</code><code class="p">)</code> <code class="n">update</code> <code class="n">documentation</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">44cd729</code> <code class="p">(</code><code class="n">tfs</code><code class="p">/</code><code class="n">featureA</code><code class="p">,</code> <code class="n">featureA</code><code class="p">)</code> <code class="n">Goodbye</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">d202b53</code> <code class="n">Branched</code> <code class="n">from</code> <code class="p">$/</code><code class="n">tfvc-test</code><code class="p">/</code><code class="n">Trunk</code>
<code class="p">|/</code>
<code class="p">*</code> <code class="n">c403405</code> <code class="n">Hello</code>
<code class="p">*</code> <code class="n">b75da1a</code> <code class="n">New</code> <code class="n">project</code></pre>

<p>Now we’re ready to complete our contribution by checking in our code to the TFVC server.
We’ll use the <code>rcheckin</code> command here to create a TFVC changeset for each Git commit in the path from HEAD to the first <code>tfs</code> remote branch found (the <code>checkin</code> command would only create one changeset, sort of like squashing Git commits).</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">tfs</code> <code class="n">rcheckin</code>
<code class="n">Working</code> <code class="n">with</code> <code class="n">tfs</code> <code class="n">remote</code><code class="err">:</code> <code class="k">default</code>
<code class="n">Fetching</code> <code class="n">changes</code> <code class="n">from</code> <code class="n">TFS</code> <code class="n">to</code> <code class="n">minimize</code> <code class="n">possibility</code> <code class="n">of</code> <code class="n">late</code> <code class="n">conflict</code><code class="p">...</code>
<code class="n">Starting</code> <code class="n">checkin</code> <code class="n">of</code> <code class="n">5cec4ab4</code> <code class="s1">'update readme'</code>
 <code class="n">add</code> <code class="n">README</code><code class="p">.</code><code class="n">md</code>
<code class="n">C20</code> <code class="p">=</code> <code class="n">71a5ddce274c19f8fdc322b4f165d93d89121017</code>
<code class="n">Done</code> <code class="n">with</code> <code class="n">5cec4ab4b213c354341f66c80cd650ab98dcf1ed</code><code class="p">,</code> <code class="n">rebasing</code> <code class="n">tail</code> <code class="n">onto</code> <code class="n">new</code> <code class="n">TFS-commit</code><code class="p">...</code>
<code class="n">Rebase</code> <code class="n">done</code> <code class="n">successfully</code><code class="p">.</code>
<code class="n">Starting</code> <code class="n">checkin</code> <code class="n">of</code> <code class="n">b1bf0f99</code> <code class="s1">'update code'</code>
 <code class="n">edit</code> <code class="p">.</code><code class="n">git</code><code class="p">\</code><code class="n">tfs</code><code class="p">\</code><code class="k">default</code><code class="p">\</code><code class="n">workspace</code><code class="p">\</code><code class="n">ConsoleApplication1</code><code class="p">/</code><code class="n">ConsoleApplication1</code><code class="p">/</code><code class="n">Program</code><code class="p">.</code><code class="n">cs</code>
<code class="n">C21</code> <code class="p">=</code> <code class="n">ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b</code>
<code class="n">Done</code> <code class="n">with</code> <code class="n">b1bf0f9977b2d48bad611ed4a03d3738df05ea5d</code><code class="p">,</code> <code class="n">rebasing</code> <code class="n">tail</code> <code class="n">onto</code> <code class="n">new</code> <code class="n">TFS-commit</code><code class="p">...</code>
<code class="n">Rebase</code> <code class="n">done</code> <code class="n">successfully</code><code class="p">.</code>
<code class="n">No</code> <code class="n">more</code> <code class="n">to</code> <code class="n">rcheckin</code><code class="p">.</code>
<code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">log</code> <code class="p">-</code><code class="n">-all</code> <code class="p">-</code><code class="n">-oneline</code> <code class="p">-</code><code class="n">-graph</code> <code class="p">-</code><code class="n">-decorate</code>
<code class="p">*</code> <code class="n">ff04e7c</code> <code class="p">(</code><code class="n">HEAD</code><code class="p">,</code> <code class="n">tfs</code><code class="p">/</code><code class="k">default</code><code class="p">,</code> <code class="n">master</code><code class="p">)</code> <code class="n">update</code> <code class="n">code</code>
<code class="p">*</code> <code class="n">71a5ddc</code> <code class="n">update</code> <code class="n">readme</code>
<code class="p">*</code> <code class="n">aea74a0</code> <code class="n">update</code> <code class="n">documentation</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">44cd729</code> <code class="p">(</code><code class="n">tfs</code><code class="p">/</code><code class="n">featureA</code><code class="p">,</code> <code class="n">featureA</code><code class="p">)</code> <code class="n">Goodbye</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">d202b53</code> <code class="n">Branched</code> <code class="n">from</code> <code class="p">$/</code><code class="n">tfvc-test</code><code class="p">/</code><code class="n">Trunk</code>
<code class="p">|/</code>
<code class="p">*</code> <code class="n">c403405</code> <code class="n">Hello</code>
<code class="p">*</code> <code class="n">b75da1a</code> <code class="n">New</code> <code class="n">project</code></pre>

<p>Notice how after every successful checkin to the TFVC server, git-tfs is rebasing the remaining work onto what it just did.
That’s because it’s adding the <code>git-tfs-id</code> field to the bottom of the commit messages, which changes the SHA-1 hashes.
This is exactly as designed, and there’s nothing to worry about, but you should be aware that it’s happening, especially if you’re sharing Git commits with others.</p>

<p>TFS has many features that integrate with its version control system, such as work items, designated reviewers, gated checkins, and so on.
It can be cumbersome to work with these features using only a command-line tool, but fortunately git-tfs lets you launch a graphical checkin tool very easily:</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">tfs</code> <code class="n">checkintool</code>
<code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">tfs</code> <code class="n">ct</code></pre>

<p>It looks a bit like this:</p>

<figure><div class="border-box"><img src="book/09-git-and-other-scms/images/git-tfs-ct.png" alt="The git-tfs checkin tool."/></div><figcaption>The git-tfs checkin tool.</figcaption></figure>

<p>This will look familiar to TFS users, as it’s the same dialog that’s launched from within Visual Studio.</p>

<p>Git-tfs also lets you control TFVC branches from your Git repository.
As an example, let’s create one:</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">tfs</code> <code class="n">branch</code> <code class="p">$/</code><code class="n">tfvc-test</code><code class="p">/</code><code class="n">featureBee</code>
<code class="n">The</code> <code class="n">name</code> <code class="n">of</code> <code class="n">the</code> <code class="n">local</code> <code class="n">branch</code> <code class="n">will</code> <code class="n">be</code> <code class="err">:</code> <code class="n">featureBee</code>
<code class="n">C26</code> <code class="p">=</code> <code class="n">1d54865c397608c004a2cadce7296f5edc22a7e5</code>
<code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">log</code> <code class="p">-</code><code class="n">-oneline</code> <code class="p">-</code><code class="n">-graph</code> <code class="p">-</code><code class="n">-decorate</code> <code class="p">-</code><code class="n">-all</code>
<code class="p">*</code> <code class="n">1d54865</code> <code class="p">(</code><code class="n">tfs</code><code class="p">/</code><code class="n">featureBee</code><code class="p">)</code> <code class="n">Creation</code> <code class="n">branch</code> <code class="p">$/</code><code class="n">myproject</code><code class="p">/</code><code class="n">featureBee</code>
<code class="p">*</code> <code class="n">ff04e7c</code> <code class="p">(</code><code class="n">HEAD</code><code class="p">,</code> <code class="n">tfs</code><code class="p">/</code><code class="k">default</code><code class="p">,</code> <code class="n">master</code><code class="p">)</code> <code class="n">update</code> <code class="n">code</code>
<code class="p">*</code> <code class="n">71a5ddc</code> <code class="n">update</code> <code class="n">readme</code>
<code class="p">*</code> <code class="n">aea74a0</code> <code class="n">update</code> <code class="n">documentation</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">44cd729</code> <code class="p">(</code><code class="n">tfs</code><code class="p">/</code><code class="n">featureA</code><code class="p">,</code> <code class="n">featureA</code><code class="p">)</code> <code class="n">Goodbye</code>
<code class="p">|</code> <code class="p">*</code> <code class="n">d202b53</code> <code class="n">Branched</code> <code class="n">from</code> <code class="p">$/</code><code class="n">tfvc-test</code><code class="p">/</code><code class="n">Trunk</code>
<code class="p">|/</code>
<code class="p">*</code> <code class="n">c403405</code> <code class="n">Hello</code>
<code class="p">*</code> <code class="n">b75da1a</code> <code class="n">New</code> <code class="n">project</code></pre>

<p>Creating a branch in TFVC means adding a changeset where that branch now exists, and this is projected as a Git commit.
Note also that git-tfs <strong>created</strong> the <code>tfs/featureBee</code> remote branch, but <code>HEAD</code> is still pointing to <code>master</code>.
If you want to work on the newly-minted branch, you’ll want to base your new commits on the <code>1d54865</code> commit, perhaps by creating a topic branch from that commit.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Git and TFS Summary" id="idp30590640">
<h3>Git and TFS Summary</h3>

<p>Git-tf and Git-tfs are both great tools for interfacing with a TFVC server.
They allow you to use the power of Git locally, avoid constantly having to round-trip to the central TFVC server, and make your life as a developer much easier, without forcing your entire team to migrate to Git.
If you’re working on Windows (which is likely if your team is using TFS), you’ll probably want to use git-tfs, since its feature set is more complete, but if you’re working on another platform, you’ll be using git-tf, which is more limited.
As with most of the tools in this chapter, you should choose one of these version-control systems to be canonical, and use the other one in a subordinate fashion – either Git or TFVC should be the center of collaboration, but not both.</p>
</section>



</section>





</section>













<section data-type="sect1" data-pdf-bookmark="Migrating to Git" id="_migrating">
<h1>Migrating to Git</h1>

<p><a data-type="indexterm" data-primary="Migrating to Git" id="idp31174816"/>
If you have an existing codebase in another VCS but you’ve decided to start using Git, you must migrate your project one way or another.
This section goes over some importers for common systems, and then demonstrates how to develop your own custom importer.
You’ll learn how to import data from several of the bigger professionally used SCM systems, because they make up the majority of users who are switching, and because high-quality tools for them are easy to come by.</p>








<section data-type="sect2" data-pdf-bookmark="Subversion" id="idp31176272">
<h2>Subversion</h2>

<p><a data-type="indexterm" data-primary="Subversion" id="idp31178160"/>
<a data-type="indexterm" data-primary="Importing" data-secondary="from Subversion" id="idp31178992"/>
If you read the previous section about using <code>git svn</code>, you can easily use those instructions to <code>git svn clone</code> a repository; then, stop using the Subversion server, push to a new Git server, and start using that.
If you want the history, you can accomplish that as quickly as you can pull the data out of the Subversion server (which may take a while).</p>

<p>However, the import isn’t perfect; and because it will take so long, you may as well do it right.
The first problem is the author information.
In Subversion, each person committing has a user on the system who is recorded in the commit information.
The examples in the previous section show <code>schacon</code> in some places, such as the <code>blame</code> output and the <code>git svn log</code>.
If you want to map this to better Git author data, you need a mapping from the Subversion users to the Git authors.
Create a file called <code>users.txt</code> that has this mapping in a format like this:</p>

<pre data-type="programlisting">schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</pre>

<p>To get a list of the author names that SVN uses, you can run this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> svn log --xml <code class="p">|</code> grep author <code class="p">|</code> sort -u <code class="p">|</code> <code class="se">\</code>
<code class="go">  perl -pe 's/.*&gt;(.*?)&lt;.*/$1 = /'</code></pre>

<p>That generates the log output in XML format, then keeps only the lines with author information, discards duplicates, strips out the XML tags.
(Obviously this only works on a machine with <code>grep</code>, <code>sort</code>, and <code>perl</code> installed.)
Then, redirect that output into your users.txt file so you can add the equivalent Git user data next to each entry.</p>

<p>You can provide this file to <code>git svn</code> to help it map the author data more accurately.
You can also tell <code>git svn</code> not to include the metadata that Subversion normally imports, by passing <code>--no-metadata</code> to the <code>clone</code> or <code>init</code> command.
This makes your <code>import</code> command look like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git svn clone http://my-project.googlecode.com/svn/ <code class="se">\</code>
<code class="go">      --authors-file=users.txt --no-metadata -s my_project</code></pre>

<p>Now you should have a nicer Subversion import in your <code>my_project</code> directory.
Instead of commits that look like this</p>

<pre data-type="programlisting">commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</pre>

<p>they look like this:</p>

<pre data-type="programlisting">commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</pre>

<p>Not only does the Author field look a lot better, but the <code>git-svn-id</code> is no longer there, either.</p>

<p>You should also do a bit of post-import cleanup.
For one thing, you should clean up the weird references that <code>git svn</code> set up.
First you’ll move the tags so they’re actual tags rather than strange remote branches, and then you’ll move the rest of the branches so they’re local.</p>

<p>To move the tags to be proper Git tags, run</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> cp -Rf .git/refs/remotes/origin/tags/* .git/refs/tags/
<code class="gp">$</code> rm -Rf .git/refs/remotes/origin/tags</pre>

<p>This takes the references that were remote branches that started with <code>remotes/origin/tags/</code> and makes them real (lightweight) tags.</p>

<p>Next, move the rest of the references under <code>refs/remotes</code> to be local branches:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> cp -Rf .git/refs/remotes/* .git/refs/heads/
<code class="gp">$</code> rm -Rf .git/refs/remotes</pre>

<p>Now all the old branches are real Git branches and all the old tags are real Git tags.
The last thing to do is add your new Git server as a remote and push to it.
Here is an example of adding your server as a remote:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git remote add origin git@my-git-server:myrepository.git</pre>

<p>Because you want all your branches and tags to go up, you can now run this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git push origin --all</pre>

<p>All your branches and tags should be on your new Git server in a nice, clean import.</p>
</section>













<section data-type="sect2" data-pdf-bookmark="Mercurial" id="idp31598944">
<h2>Mercurial</h2>

<p><a data-type="indexterm" data-primary="Mercurial" id="idp31536464"/><a data-type="indexterm" data-primary="Importing" data-secondary="from Mercurial" id="idp31537168"/>
Since Mercurial and Git have fairly similar models for representing versions, and since Git is a bit more flexible, converting a repository from Mercurial to Git is fairly straightforward, using a tool called “hg-fast-export”, which you’ll need a copy of:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git clone http://repo.or.cz/r/fast-export.git /tmp/fast-export</pre>

<p>The first step in the conversion is to get a full clone of the Mercurial repository you want to convert:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> hg clone &lt;remote repo URL&gt; /tmp/hg-repo</pre>

<p>The next step is to create an author mapping file.
Mercurial is a bit more forgiving than Git for what it will put in the author field for changesets, so this is a good time to clean house.
Generating this is a one-line command in a <code>bash</code> shell:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">cd</code> /tmp/hg-repo
<code class="gp">$</code> hg log <code class="p">|</code> grep user: <code class="p">|</code> sort <code class="p">|</code> uniq <code class="p">|</code> sed <code class="s1">'s/user: *//'</code> &gt; ../authors</pre>

<p>This will take a few seconds, depending on how long your project’s history is, and afterwards the <code>/tmp/authors</code> file will look something like this:</p>

<pre data-type="programlisting">bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;</pre>

<p>In this example, the same person (Bob) has created changesets under four different names, one of which actually looks correct, and one of which would be completely invalid for a Git commit.
Hg-fast-export lets us fix this by adding <code>={new name and email address}</code> at the end of every line we want to change, and removing the lines for any usernames that we want to leave alone.
If all the usernames look fine, we won’t need this file at all.
In this example, we want our file to look like this:</p>

<pre data-type="programlisting">bob=Bob Jones &lt;bob@company.com&gt;
bob@localhost=Bob Jones &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;=Bob Jones &lt;bob@company.com&gt;
bob &lt;bob@company.com&gt;=Bob Jones &lt;bob@company.com&gt;</pre>

<p>The next step is to create our new Git repository, and run the export script:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git init /tmp/converted
<code class="gp">$</code> <code class="nb">cd</code> /tmp/converted
<code class="gp">$</code> /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</pre>

<p>The <code>-r</code> flag tells hg-fast-export where to find the Mercurial repository we want to convert, and the <code>-A</code> flag tells it where to find the author-mapping file.
The script parses Mercurial changesets and converts them into a script for Git’s “fast-import” feature (which we’ll discuss in detail a bit later on).
This takes a bit (though it’s <em>much</em> faster than it would be over the network), and the output is fairly verbose:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
<code class="go">Loaded 4 authors</code>
<code class="go">master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files</code>
<code class="go">master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files</code>
<code class="go">master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files</code>
<code class="go">[…]</code>
<code class="go">master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files</code>
<code class="go">master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files</code>
<code class="go">master: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files</code>
<code class="go">Exporting tag [0.4c] at [hg r9] [git :10]</code>
<code class="go">Exporting tag [0.4d] at [hg r16] [git :17]</code>
<code class="go">[…]</code>
<code class="go">Exporting tag [3.1-rc] at [hg r21926] [git :21927]</code>
<code class="go">Exporting tag [3.1] at [hg r21973] [git :21974]</code>
<code class="go">Issued 22315 commands</code>
<code class="go">git-fast-import statistics:</code>
<code class="go">---------------------------------------------------------------------</code>
<code class="go">Alloc'd objects:     120000</code>
<code class="go">Total objects:       115032 (    208171 duplicates                  )</code>
<code class="go">      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)</code>
<code class="go">      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)</code>
<code class="go">      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)</code>
<code class="go">      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)</code>
<code class="go">Total branches:         109 (         2 loads     )</code>
<code class="go">      marks:        1048576 (     22208 unique    )</code>
<code class="go">      atoms:           1952</code>
<code class="go">Memory total:          7860 KiB</code>
<code class="go">       pools:          2235 KiB</code>
<code class="go">     objects:          5625 KiB</code>
<code class="go">---------------------------------------------------------------------</code>
<code class="go">pack_report: getpagesize()            =       4096</code>
<code class="go">pack_report: core.packedGitWindowSize = 1073741824</code>
<code class="go">pack_report: core.packedGitLimit      = 8589934592</code>
<code class="go">pack_report: pack_used_ctr            =      90430</code>
<code class="go">pack_report: pack_mmap_calls          =      46771</code>
<code class="go">pack_report: pack_open_windows        =          1 /          1</code>
<code class="go">pack_report: pack_mapped              =  340852700 /  340852700</code>
<code class="go">---------------------------------------------------------------------</code>

<code class="gp">$</code> git shortlog -sn
<code class="go">   369  Bob Jones</code>
<code class="go">   365  Joe Smith</code></pre>

<p>That’s pretty much all there is to it.
All of the Mercurial tags have been converted to Git tags, and Mercurial branches and bookmarks have been converted to Git branches.
Now you’re ready to push the repository up to its new server-side home:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git remote add origin git@my-git-server:myrepository.git
<code class="gp">$</code> git push origin --all</pre>
</section>













<section data-type="sect2" data-pdf-bookmark="Perforce" id="_perforce_import">
<h2>Perforce</h2>

<p><a data-type="indexterm" data-primary="Perforce" id="idp31719552"/><a data-type="indexterm" data-primary="Importing" data-secondary="from Perforce" id="idp31720256"/>
The next system you’ll look at importing from is Perforce.
As we discussed above, there are two ways to let Git and Perforce talk to each other: git-p4 and Perforce Git Fusion.</p>










<section data-type="sect3" data-pdf-bookmark="Perforce Git Fusion" id="idp31756688">
<h3>Perforce Git Fusion</h3>

<p>Git Fusion makes this process fairly painless.
Just configure your project settings, user mappings, and branches using a configuration file (as discussed in <a data-type="xref" href="#_p4_git_fusion">“Git Fusion”</a>), and clone the repository.
Git Fusion leaves you with what looks like a native Git repository, which is then ready to push to a native Git host if you desire.
You could even use Perforce as your Git host if you like.</p>
</section>













<section data-type="sect3" data-pdf-bookmark="Git-p4" id="_git_p4">
<h3>Git-p4</h3>

<p>Git-p4 can also act as an import tool.
As an example, we’ll import the Jam project from the Perforce Public Depot.
To set up your client, you must export the P4PORT environment variable to point to the Perforce depot:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">export </code><code class="nv">P4PORT</code><code class="o">=</code>public.perforce.com:1666</pre>
<div data-type="note">
<p>In order to follow along, you’ll need a Perforce depot to connect with.
We’ll be using the public depot at public.perforce.com for our examples, but you can use any depot you have access to.</p>
</div>

<p><a data-type="indexterm" data-primary="git commands" data-secondary="p4" id="idp31860816"/>
Run the <code>git p4 clone</code> command to import the Jam project from the Perforce server, supplying the depot and project path and the path into which you want to import the project:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git-p4 clone //guest/perforce_software/jam@all p4import
<code class="go">Importing from //guest/perforce_software/jam@all into p4import</code>
<code class="go">Initialized empty Git repository in /private/tmp/p4import/.git/</code>
<code class="go">Import destination: refs/remotes/p4/master</code>
<code class="go">Importing revision 9957 (100%)</code></pre>

<p>This particular project has only one branch, but if you have branches that are configured with branch views (or just a set of directories), you can use the <code>--detect-branches</code> flag to <code>git p4 clone</code> to import all the project’s branches as well.
See <a data-type="xref" href="#_git_p4_branches">“Branching”</a> for a bit more detail on this.</p>

<p>At this point you’re almost done.
If you go to the <code>p4import</code> directory and run <code>git log</code>, you can see your imported work:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log -2
<code class="go">commit e5da1c909e5db3036475419f6379f2c73710c4e6</code>
<code class="go">Author: giles &lt;giles@giles@perforce.com&gt;</code>
<code class="go">Date:   Wed Feb 8 03:13:27 2012 -0800</code>

<code class="go">    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.</code>

<code class="go">    [git-p4: depot-paths = "//public/jam/src/": change = 8068]</code>

<code class="go">commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98</code>
<code class="go">Author: kwirth &lt;kwirth@perforce.com&gt;</code>
<code class="go">Date:   Tue Jul 7 01:35:51 2009 -0800</code>

<code class="go">    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</code>

<code class="go">    [git-p4: depot-paths = "//public/jam/src/": change = 7304]</code></pre>

<p>You can see that <code>git-p4</code> has left an identifier in each commit message.
It’s fine to keep that identifier there, in case you need to reference the Perforce change number later.
However, if you’d like to remove the identifier, now is the time to do so – before you start doing work on the new repository.
<a data-type="indexterm" data-primary="git commands" data-secondary="filter-branch" id="idp31825248"/>
You can use <code>git filter-branch</code> to remove the identifier strings en masse:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git filter-branch --msg-filter <code class="s1">'sed -e "/^\[git-p4:/d"'</code>
<code class="go">Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)</code>
<code class="go">Ref 'refs/heads/master' was rewritten</code></pre>

<p>If you run <code>git log</code>, you can see that all the SHA-1 checksums for the commits have changed, but the <code>git-p4</code> strings are no longer in the commit messages:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log -2
<code class="go">commit b17341801ed838d97f7800a54a6f9b95750839b7</code>
<code class="go">Author: giles &lt;giles@giles@perforce.com&gt;</code>
<code class="go">Date:   Wed Feb 8 03:13:27 2012 -0800</code>

<code class="go">    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.</code>

<code class="go">commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff</code>
<code class="go">Author: kwirth &lt;kwirth@perforce.com&gt;</code>
<code class="go">Date:   Tue Jul 7 01:35:51 2009 -0800</code>

<code class="go">    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</code></pre>

<p>Your import is ready to push up to your new Git server.</p>
</section>



</section>













<section data-type="sect2" data-pdf-bookmark="TFS" id="_git_tfs">
<h2>TFS</h2>

<p><a data-type="indexterm" data-primary="TFS" id="idp31778608"/><a data-type="indexterm" data-primary="Importing" data-secondary="from TFS" id="idp31779312"/>
If your team is converting their source control from TFVC to Git, you’ll want the highest-fidelity conversion you can get.
This means that, while we covered both git-tfs and git-tf for the interop section, we’ll only be covering git-tfs for this part, because git-tfs supports branches, and this is prohibitively difficult using git-tf.</p>
<div data-type="note">
<p>This is a one-way conversion.
The resulting Git repository won’t be able to connect with the original TFVC project.</p>
</div>

<p>The first thing to do is map usernames.
TFVC is fairly liberal with what goes into the author field for changesets, but Git wants a human-readable name and email address.
You can get this information from the <code>tf</code> command-line client, like so:</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">tf</code> <code class="n">history</code> <code class="p">$/</code><code class="n">myproject</code> <code class="n">-recursive</code> <code class="p">&gt;</code> <code class="n">AUTHORS_TMP</code></pre>

<p>This grabs all of the changesets in the history of the project and put it in the AUTHORS_TMP file that we will process to extract the data of the <em>User</em> column (the 2nd one).
Open the file and find at which characters start and end the column and replace, in the following command-line, the parameters <code>11-20</code> of the <code>cut</code> command with the ones found:</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">cat</code> <code class="n">AUTHORS_TMP</code> <code class="p">|</code> <code class="n">cut</code> <code class="n">-b</code> <code class="n">11</code><code class="p">-</code><code class="n">20</code> <code class="p">|</code> <code class="n">tail</code> <code class="n">-n</code><code class="p">+</code><code class="n">3</code> <code class="p">|</code> <code class="n">uniq</code> <code class="p">|</code> <code class="n">sort</code> <code class="p">&gt;</code> <code class="n">AUTHORS</code></pre>

<p>The <code>cut</code> command keeps only the characters between 11 and 20 from each line.
The <code>tail</code> command skips the first two lines, which are field headers and ASCII-art underlines.
The result of all of this is piped to <code>uniq</code> to eliminate duplicates, and saved to a file named <code>AUTHORS</code>.
The next step is manual; in order for git-tfs to make effective use of this file, each line must be in this format:</p>

<pre data-type="programlisting" data-code-language="text">DOMAIN\username = User Name &lt;email@address.com&gt;</pre>

<p>The portion on the left is the “User” field from TFVC, and the portion on the right side of the equals sign is the user name that will be used for Git commits.</p>

<p>Once you have this file, the next thing to do is make a full clone of the TFVC project you’re interested in:</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="n">tfs</code> <code class="n">clone</code> <code class="p">-</code><code class="n">-with-branches</code> <code class="p">-</code><code class="n">-authors</code><code class="p">=</code><code class="n">AUTHORS</code> <code class="n">https</code><code class="err">:</code><code class="p">//</code><code class="n">username</code><code class="p">.</code><code class="n">visualstudio</code><code class="p">.</code><code class="n">com</code><code class="p">/</code><code class="n">DefaultCollection</code> <code class="p">$/</code><code class="n">project</code><code class="p">/</code><code class="n">Trunk</code> <code class="n">project_git</code></pre>

<p>Next you’ll want to clean the <code>git-tfs-id</code> sections from the bottom of the commit messages.
The following command will do that:</p>

<pre data-type="programlisting" data-code-language="powershell"><code class="n">PS</code><code class="p">&gt;</code> <code class="n">git</code> <code class="k">filter</code><code class="n">-branch</code> <code class="o">-f</code> <code class="p">-</code><code class="n">-msg-filter</code> <code class="s1">'sed "s/^git-tfs-id:.*$//g"'</code> <code class="p">--</code> <code class="p">-</code><code class="n">-all</code></pre>

<p>That uses the <code>sed</code> command from the Git-bash environment to replace any line starting with “git-tfs-id:” with emptiness, which Git will then ignore.</p>

<p>Once that’s all done, you’re ready to add a new remote, push all your branches up, and have your team start working from Git.</p>
</section>













<section data-type="sect2" data-pdf-bookmark="A Custom Importer" id="_custom_importer">
<h2>A Custom Importer</h2>

<p><a data-type="indexterm" data-primary="git commands" data-secondary="fast-import" id="idp32051456"/>
<a data-type="indexterm" data-primary="Importing" data-secondary="from others" id="idp32056384"/>
If your system isn’t one of the above, you should look for an importer online – quality importers are available for many other systems, including CVS, Clear Case, Visual Source Safe, even a directory of archives.
If none of these tools works for you, you have a more obscure tool, or you otherwise need a more custom importing process, you should use <code>git fast-import</code>.
This command reads simple instructions from stdin to write specific Git data.
It’s much easier to create Git objects this way than to run the raw Git commands or try to write the raw objects (see <a data-type="xref" href="ch10.html#_git_internals">Chapter 10</a> for more information).
This way, you can write an import script that reads the necessary information out of the system you’re importing from and prints straightforward instructions to stdout.
You can then run this program and pipe its output through <code>git fast-import</code>.</p>

<p>To quickly demonstrate, you’ll write a simple importer.
Suppose you work in <code>current</code>, you back up your project by occasionally copying the directory into a time-stamped <code>back_YYYY_MM_DD</code> backup directory, and you want to import this into Git.
Your directory structure looks like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> ls /opt/import_from
<code class="go">back_2014_01_02</code>
<code class="go">back_2014_01_04</code>
<code class="go">back_2014_01_14</code>
<code class="go">back_2014_02_03</code>
<code class="go">current</code></pre>

<p>In order to import a Git directory, you need to review how Git stores its data.
As you may remember, Git is fundamentally a linked list of commit objects that point to a snapshot of content.
All you have to do is tell <code>fast-import</code> what the content snapshots are, what commit data points to them, and the order they go in.
Your strategy will be to go through the snapshots one at a time and create commits with the contents of each directory, linking each commit back to the previous one.</p>

<p>As we did in <a data-type="xref" href="ch08.html#_an_example_git_enforced_policy">“An Example Git-Enforced Policy”</a>, we’ll write this in Ruby, because it’s what we generally work with and it tends to be easy to read.
You can write this example pretty easily in anything you’re familiar with – it just needs to print the appropriate information to <code>stdout</code>.
And, if you are running on Windows, this means you’ll need to take special care to not introduce carriage returns at the end your lines – git fast-import is very particular about just wanting line feeds (LF) not the carriage return line feeds (CRLF) that Windows uses.</p>

<p>To begin, you’ll change into the target directory and identify every subdirectory, each of which is a snapshot that you want to import as a commit.
You’ll change into each subdirectory and print the commands necessary to export it.
Your basic main loop looks like this:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="n">last_mark</code> <code class="o">=</code> <code class="kp">nil</code>

<code class="c1"># loop through the directories</code>
<code class="no">Dir</code><code class="o">.</code><code class="n">chdir</code><code class="p">(</code><code class="no">ARGV</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="p">)</code> <code class="k">do</code>
  <code class="no">Dir</code><code class="o">.</code><code class="n">glob</code><code class="p">(</code><code class="s2">"*"</code><code class="p">)</code><code class="o">.</code><code class="n">each</code> <code class="k">do</code> <code class="o">|</code><code class="n">dir</code><code class="o">|</code>
    <code class="k">next</code> <code class="k">if</code> <code class="no">File</code><code class="o">.</code><code class="n">file?</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code>

    <code class="c1"># move into the target directory</code>
    <code class="no">Dir</code><code class="o">.</code><code class="n">chdir</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code> <code class="k">do</code>
      <code class="n">last_mark</code> <code class="o">=</code> <code class="n">print_export</code><code class="p">(</code><code class="n">dir</code><code class="p">,</code> <code class="n">last_mark</code><code class="p">)</code>
    <code class="k">end</code>
  <code class="k">end</code>
<code class="k">end</code></pre>

<p>You run <code>print_export</code> inside each directory, which takes the manifest and mark of the previous snapshot and returns the manifest and mark of this one; that way, you can link them properly.
“Mark” is the <code>fast-import</code> term for an identifier you give to a commit; as you create commits, you give each one a mark that you can use to link to it from other commits.
So, the first thing to do in your <code>print_export</code> method is generate a mark from the directory name:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="n">mark</code> <code class="o">=</code> <code class="n">convert_dir_to_mark</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code></pre>

<p>You’ll do this by creating an array of directories and using the index value as the mark, because a mark must be an integer.
Your method looks like this:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="vg">$marks</code> <code class="o">=</code> <code class="o">[]</code>
<code class="k">def</code> <code class="nf">convert_dir_to_mark</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code>
  <code class="k">if</code> <code class="o">!</code><code class="vg">$marks</code><code class="o">.</code><code class="n">include?</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code>
    <code class="vg">$marks</code> <code class="o">&lt;&lt;</code> <code class="n">dir</code>
  <code class="k">end</code>
  <code class="p">(</code><code class="vg">$marks</code><code class="o">.</code><code class="n">index</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code><code class="o">.</code><code class="n">to_s</code>
<code class="k">end</code></pre>

<p>Now that you have an integer representation of your commit, you need a date for the commit metadata.
Because the date is expressed in the name of the directory, you’ll parse it out.
The next line in your <code>print_export</code> file is</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="n">date</code> <code class="o">=</code> <code class="n">convert_dir_to_date</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code></pre>

<p>where <code>convert_dir_to_date</code> is defined as</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="k">def</code> <code class="nf">convert_dir_to_date</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code>
  <code class="k">if</code> <code class="n">dir</code> <code class="o">==</code> <code class="s1">'current'</code>
    <code class="k">return</code> <code class="no">Time</code><code class="o">.</code><code class="n">now</code><code class="p">()</code><code class="o">.</code><code class="n">to_i</code>
  <code class="k">else</code>
    <code class="n">dir</code> <code class="o">=</code> <code class="n">dir</code><code class="o">.</code><code class="n">gsub</code><code class="p">(</code><code class="s1">'back_'</code><code class="p">,</code> <code class="s1">''</code><code class="p">)</code>
    <code class="p">(</code><code class="n">year</code><code class="p">,</code> <code class="n">month</code><code class="p">,</code> <code class="n">day</code><code class="p">)</code> <code class="o">=</code> <code class="n">dir</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="s1">'_'</code><code class="p">)</code>
    <code class="k">return</code> <code class="no">Time</code><code class="o">.</code><code class="n">local</code><code class="p">(</code><code class="n">year</code><code class="p">,</code> <code class="n">month</code><code class="p">,</code> <code class="n">day</code><code class="p">)</code><code class="o">.</code><code class="n">to_i</code>
  <code class="k">end</code>
<code class="k">end</code></pre>

<p>That returns an integer value for the date of each directory.
The last piece of meta-information you need for each commit is the committer data, which you hardcode in a global variable:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="vg">$author</code> <code class="o">=</code> <code class="s1">'John Doe &lt;john@example.com&gt;'</code></pre>

<p>Now you’re ready to begin printing out the commit data for your importer.
The initial information states that you’re defining a commit object and what branch it’s on, followed by the mark you’ve generated, the committer information and commit message, and then the previous commit, if any.
The code looks like this:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="c1"># print the import information</code>
<code class="nb">puts</code> <code class="s1">'commit refs/heads/master'</code>
<code class="nb">puts</code> <code class="s1">'mark :'</code> <code class="o">+</code> <code class="n">mark</code>
<code class="nb">puts</code> <code class="s2">"committer </code><code class="si">#{</code><code class="vg">$author</code><code class="si">}</code><code class="s2"> </code><code class="si">#{</code><code class="n">date</code><code class="si">}</code><code class="s2"> -0700"</code>
<code class="n">export_data</code><code class="p">(</code><code class="s1">'imported from '</code> <code class="o">+</code> <code class="n">dir</code><code class="p">)</code>
<code class="nb">puts</code> <code class="s1">'from :'</code> <code class="o">+</code> <code class="n">last_mark</code> <code class="k">if</code> <code class="n">last_mark</code></pre>

<p>You hardcode the time zone (-0700) because doing so is easy.
If you’re importing from another system, you must specify the time zone as an offset.
The commit message must be expressed in a special format:</p>

<pre data-type="programlisting">data (size)\n(contents)</pre>

<p>The format consists of the word data, the size of the data to be read, a newline, and finally the data.
Because you need to use the same format to specify the file contents later, you create a helper method, <code>export_data</code>:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="k">def</code> <code class="nf">export_data</code><code class="p">(</code><code class="n">string</code><code class="p">)</code>
  <code class="nb">print</code> <code class="s2">"data </code><code class="si">#{</code><code class="n">string</code><code class="o">.</code><code class="n">size</code><code class="si">}</code><code class="se">\n</code><code class="si">#{</code><code class="n">string</code><code class="si">}</code><code class="s2">"</code>
<code class="k">end</code></pre>

<p>All that’s left is to specify the file contents for each snapshot.
This is easy, because you have each one in a directory – you can print out the <code>deleteall</code> command followed by the contents of each file in the directory.
Git will then record each snapshot appropriately:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="nb">puts</code> <code class="s1">'deleteall'</code>
<code class="no">Dir</code><code class="o">.</code><code class="n">glob</code><code class="p">(</code><code class="s2">"**/*"</code><code class="p">)</code><code class="o">.</code><code class="n">each</code> <code class="k">do</code> <code class="o">|</code><code class="n">file</code><code class="o">|</code>
  <code class="k">next</code> <code class="k">if</code> <code class="o">!</code><code class="no">File</code><code class="o">.</code><code class="n">file?</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>
  <code class="n">inline_data</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>
<code class="k">end</code></pre>

<p>Note:  Because many systems think of their revisions as changes from one commit to another, fast-import can also take commands with each commit to specify which files have been added, removed, or modified and what the new contents are.
You could calculate the differences between snapshots and provide only this data, but doing so is more complex – you may as well give Git all the data and let it figure it out.
If this is better suited to your data, check the <code>fast-import</code> man page for details about how to provide your data in this manner.</p>

<p>The format for listing the new file contents or specifying a modified file with the new contents is as follows:</p>

<pre data-type="programlisting">M 644 inline path/to/file
data (size)
(file contents)</pre>

<p>Here, 644 is the mode (if you have executable files, you need to detect and specify 755 instead), and inline says you’ll list the contents immediately after this line.
Your <code>inline_data</code> method looks like this:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="k">def</code> <code class="nf">inline_data</code><code class="p">(</code><code class="n">file</code><code class="p">,</code> <code class="n">code</code> <code class="o">=</code> <code class="s1">'M'</code><code class="p">,</code> <code class="n">mode</code> <code class="o">=</code> <code class="s1">'644'</code><code class="p">)</code>
  <code class="n">content</code> <code class="o">=</code> <code class="no">File</code><code class="o">.</code><code class="n">read</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>
  <code class="nb">puts</code> <code class="s2">"</code><code class="si">#{</code><code class="n">code</code><code class="si">}</code><code class="s2"> </code><code class="si">#{</code><code class="n">mode</code><code class="si">}</code><code class="s2"> inline </code><code class="si">#{</code><code class="n">file</code><code class="si">}</code><code class="s2">"</code>
  <code class="n">export_data</code><code class="p">(</code><code class="n">content</code><code class="p">)</code>
<code class="k">end</code></pre>

<p>You reuse the <code>export_data</code> method you defined earlier, because it’s the same as the way you specified your commit message data.</p>

<p>The last thing you need to do is to return the current mark so it can be passed to the next iteration:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="k">return</code> <code class="n">mark</code></pre>
<div data-type="note">
<p>If you are running on Windows you’ll need to make sure that you add one extra step.
As mentioned before, Windows uses CRLF for new line characters while git fast-import expects only LF.
To get around this problem and make git fast-import happy, you need to tell ruby to use LF instead of CRLF:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="vg">$stdout</code><code class="o">.</code><code class="n">binmode</code></pre>
</div>

<p>That’s it.
Here’s the script in its entirety:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="c1">#!/usr/bin/env ruby</code>

<code class="vg">$stdout</code><code class="o">.</code><code class="n">binmode</code>
<code class="vg">$author</code> <code class="o">=</code> <code class="s2">"John Doe &lt;john@example.com&gt;"</code>

<code class="vg">$marks</code> <code class="o">=</code> <code class="o">[]</code>
<code class="k">def</code> <code class="nf">convert_dir_to_mark</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code>
    <code class="k">if</code> <code class="o">!</code><code class="vg">$marks</code><code class="o">.</code><code class="n">include?</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code>
        <code class="vg">$marks</code> <code class="o">&lt;&lt;</code> <code class="n">dir</code>
    <code class="k">end</code>
    <code class="p">(</code><code class="vg">$marks</code><code class="o">.</code><code class="n">index</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code><code class="o">+</code><code class="mi">1</code><code class="p">)</code><code class="o">.</code><code class="n">to_s</code>
<code class="k">end</code>


<code class="k">def</code> <code class="nf">convert_dir_to_date</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code>
    <code class="k">if</code> <code class="n">dir</code> <code class="o">==</code> <code class="s1">'current'</code>
        <code class="k">return</code> <code class="no">Time</code><code class="o">.</code><code class="n">now</code><code class="p">()</code><code class="o">.</code><code class="n">to_i</code>
    <code class="k">else</code>
        <code class="n">dir</code> <code class="o">=</code> <code class="n">dir</code><code class="o">.</code><code class="n">gsub</code><code class="p">(</code><code class="s1">'back_'</code><code class="p">,</code> <code class="s1">''</code><code class="p">)</code>
        <code class="p">(</code><code class="n">year</code><code class="p">,</code> <code class="n">month</code><code class="p">,</code> <code class="n">day</code><code class="p">)</code> <code class="o">=</code> <code class="n">dir</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="s1">'_'</code><code class="p">)</code>
        <code class="k">return</code> <code class="no">Time</code><code class="o">.</code><code class="n">local</code><code class="p">(</code><code class="n">year</code><code class="p">,</code> <code class="n">month</code><code class="p">,</code> <code class="n">day</code><code class="p">)</code><code class="o">.</code><code class="n">to_i</code>
    <code class="k">end</code>
<code class="k">end</code>

<code class="k">def</code> <code class="nf">export_data</code><code class="p">(</code><code class="n">string</code><code class="p">)</code>
    <code class="nb">print</code> <code class="s2">"data </code><code class="si">#{</code><code class="n">string</code><code class="o">.</code><code class="n">size</code><code class="si">}</code><code class="se">\n</code><code class="si">#{</code><code class="n">string</code><code class="si">}</code><code class="s2">"</code>
<code class="k">end</code>

<code class="k">def</code> <code class="nf">inline_data</code><code class="p">(</code><code class="n">file</code><code class="p">,</code> <code class="n">code</code><code class="o">=</code><code class="s1">'M'</code><code class="p">,</code> <code class="n">mode</code><code class="o">=</code><code class="s1">'644'</code><code class="p">)</code>
    <code class="n">content</code> <code class="o">=</code> <code class="no">File</code><code class="o">.</code><code class="n">read</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>
    <code class="nb">puts</code> <code class="s2">"</code><code class="si">#{</code><code class="n">code</code><code class="si">}</code><code class="s2"> </code><code class="si">#{</code><code class="n">mode</code><code class="si">}</code><code class="s2"> inline </code><code class="si">#{</code><code class="n">file</code><code class="si">}</code><code class="s2">"</code>
    <code class="n">export_data</code><code class="p">(</code><code class="n">content</code><code class="p">)</code>
<code class="k">end</code>

<code class="k">def</code> <code class="nf">print_export</code><code class="p">(</code><code class="n">dir</code><code class="p">,</code> <code class="n">last_mark</code><code class="p">)</code>
    <code class="n">date</code> <code class="o">=</code> <code class="n">convert_dir_to_date</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code>
    <code class="n">mark</code> <code class="o">=</code> <code class="n">convert_dir_to_mark</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code>

    <code class="nb">puts</code> <code class="s1">'commit refs/heads/master'</code>
    <code class="nb">puts</code> <code class="s2">"mark :</code><code class="si">#{</code><code class="n">mark</code><code class="si">}</code><code class="s2">"</code>
    <code class="nb">puts</code> <code class="s2">"committer </code><code class="si">#{</code><code class="vg">$author</code><code class="si">}</code><code class="s2"> </code><code class="si">#{</code><code class="n">date</code><code class="si">}</code><code class="s2"> -0700"</code>
    <code class="n">export_data</code><code class="p">(</code><code class="s2">"imported from </code><code class="si">#{</code><code class="n">dir</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code>
    <code class="nb">puts</code> <code class="s2">"from :</code><code class="si">#{</code><code class="n">last_mark</code><code class="si">}</code><code class="s2">"</code> <code class="k">if</code> <code class="n">last_mark</code>

    <code class="nb">puts</code> <code class="s1">'deleteall'</code>
    <code class="no">Dir</code><code class="o">.</code><code class="n">glob</code><code class="p">(</code><code class="s2">"**/*"</code><code class="p">)</code><code class="o">.</code><code class="n">each</code> <code class="k">do</code> <code class="o">|</code><code class="n">file</code><code class="o">|</code>
        <code class="k">next</code> <code class="k">if</code> <code class="o">!</code><code class="no">File</code><code class="o">.</code><code class="n">file?</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>
        <code class="n">inline_data</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>
    <code class="k">end</code>
    <code class="n">mark</code>
<code class="k">end</code>


<code class="c1"># Loop through the directories</code>
<code class="n">last_mark</code> <code class="o">=</code> <code class="kp">nil</code>
<code class="no">Dir</code><code class="o">.</code><code class="n">chdir</code><code class="p">(</code><code class="no">ARGV</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="p">)</code> <code class="k">do</code>
    <code class="no">Dir</code><code class="o">.</code><code class="n">glob</code><code class="p">(</code><code class="s2">"*"</code><code class="p">)</code><code class="o">.</code><code class="n">each</code> <code class="k">do</code> <code class="o">|</code><code class="n">dir</code><code class="o">|</code>
        <code class="k">next</code> <code class="k">if</code> <code class="no">File</code><code class="o">.</code><code class="n">file?</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code>

        <code class="c1"># move into the target directory</code>
        <code class="no">Dir</code><code class="o">.</code><code class="n">chdir</code><code class="p">(</code><code class="n">dir</code><code class="p">)</code> <code class="k">do</code>
            <code class="n">last_mark</code> <code class="o">=</code> <code class="n">print_export</code><code class="p">(</code><code class="n">dir</code><code class="p">,</code> <code class="n">last_mark</code><code class="p">)</code>
        <code class="k">end</code>
    <code class="k">end</code>
<code class="k">end</code></pre>

<p>If you run this script, you’ll get content that looks something like this:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> ruby import.rb /opt/import_from
<code class="go">commit refs/heads/master</code>
<code class="go">mark :1</code>
<code class="go">committer John Doe &lt;john@example.com&gt; 1388649600 -0700</code>
<code class="go">data 29</code>
<code class="go">imported from back_2014_01_02deleteall</code>
<code class="go">M 644 inline README.md</code>
<code class="go">data 28</code>
<code class="gp">#</code> Hello

<code class="go">This is my readme.</code>
<code class="go">commit refs/heads/master</code>
<code class="go">mark :2</code>
<code class="go">committer John Doe &lt;john@example.com&gt; 1388822400 -0700</code>
<code class="go">data 29</code>
<code class="go">imported from back_2014_01_04from :1</code>
<code class="go">deleteall</code>
<code class="go">M 644 inline main.rb</code>
<code class="go">data 34</code>
<code class="gp">#</code>!/bin/env ruby

<code class="go">puts "Hey there"</code>
<code class="go">M 644 inline README.md</code>
<code class="go">(...)</code></pre>

<p>To run the importer, pipe this output through <code>git fast-import</code> while in the Git directory you want to import into.
You can create a new directory and then run <code>git init</code> in it for a starting point, and then run your script:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git init
<code class="go">Initialized empty Git repository in /opt/import_to/.git/</code>
<code class="gp">$</code> ruby import.rb /opt/import_from <code class="p">|</code> git fast-import
<code class="go">git-fast-import statistics:</code>
<code class="go">---------------------------------------------------------------------</code>
<code class="go">Alloc'd objects:       5000</code>
<code class="go">Total objects:           13 (         6 duplicates                  )</code>
<code class="go">      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)</code>
<code class="go">      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)</code>
<code class="go">      commits:            4 (         1 duplicates          0 deltas of          0 attempts)</code>
<code class="go">      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)</code>
<code class="go">Total branches:           1 (         1 loads     )</code>
<code class="go">      marks:           1024 (         5 unique    )</code>
<code class="go">      atoms:              2</code>
<code class="go">Memory total:          2344 KiB</code>
<code class="go">       pools:          2110 KiB</code>
<code class="go">     objects:           234 KiB</code>
<code class="go">---------------------------------------------------------------------</code>
<code class="go">pack_report: getpagesize()            =       4096</code>
<code class="go">pack_report: core.packedGitWindowSize = 1073741824</code>
<code class="go">pack_report: core.packedGitLimit      = 8589934592</code>
<code class="go">pack_report: pack_used_ctr            =         10</code>
<code class="go">pack_report: pack_mmap_calls          =          5</code>
<code class="go">pack_report: pack_open_windows        =          2 /          2</code>
<code class="go">pack_report: pack_mapped              =       1457 /       1457</code>
<code class="go">---------------------------------------------------------------------</code></pre>

<p>As you can see, when it completes successfully, it gives you a bunch of statistics about what it accomplished.
In this case, you imported 13 objects total for 4 commits into 1 branch.
Now, you can run <code>git log</code> to see your new history:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log -2
<code class="go">commit 3caa046d4aac682a55867132ccdfbe0d3fdee498</code>
<code class="go">Author: John Doe &lt;john@example.com&gt;</code>
<code class="go">Date:   Tue Jul 29 19:39:04 2014 -0700</code>

<code class="go">    imported from current</code>

<code class="go">commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def</code>
<code class="go">Author: John Doe &lt;john@example.com&gt;</code>
<code class="go">Date:   Mon Feb 3 01:00:00 2014 -0700</code>

<code class="go">    imported from back_2014_02_03</code></pre>

<p>There you go – a nice, clean Git repository.
It’s important to note that nothing is checked out – you don’t have any files in your working directory at first.
To get them, you must reset your branch to where <code>master</code> is now:</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> ls
<code class="gp">$</code> git reset --hard master
<code class="go">HEAD is now at 3caa046 imported from current</code>
<code class="gp">$</code> ls
<code class="go">README.md main.rb</code></pre>

<p>You can do a lot more with the <code>fast-import</code> tool – handle different modes, binary data, multiple branches and merging, tags, progress indicators, and more.
A number of examples of more complex scenarios are available in the <code>contrib/fast-import</code> directory of the Git source code.</p>
</section>





</section>













<section data-type="sect1" data-pdf-bookmark="Summary" id="idp33106128">
<h1>Summary</h1>

<p>You should feel comfortable using Git as a client for other version-control systems, or importing nearly any existing repository into Git without losing data.
In the next chapter, we’ll cover the raw internals of Git so you can craft every single byte, if need be.</p>
</section>







</section>
    <div class="navigation">
      <ul>
        <li><a href="ch10.html">Next</a></li>
        <li><a href="ch08.html">Previous</a></li>
      </ul>
    </div>
  </body>
</html>
